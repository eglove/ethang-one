# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type AffectedRowsOutput {
    count: Int!
}

type AggregateBlog {
    _count: BlogCountAggregate
    _max: BlogMaxAggregate
    _min: BlogMinAggregate
}

type AggregateBlogAuthor {
    _count: BlogAuthorCountAggregate
    _max: BlogAuthorMaxAggregate
    _min: BlogAuthorMinAggregate
}

type AggregateCourse {
    _avg: CourseAvgAggregate
    _count: CourseCountAggregate
    _max: CourseMaxAggregate
    _min: CourseMinAggregate
    _sum: CourseSumAggregate
}

type AggregateCourseInstructor {
    _count: CourseInstructorCountAggregate
    _max: CourseInstructorMaxAggregate
    _min: CourseInstructorMinAggregate
}

type AggregateImage {
    _count: ImageCountAggregate
    _max: ImageMaxAggregate
    _min: ImageMinAggregate
}

type AggregatePerson {
    _count: PersonCountAggregate
    _max: PersonMaxAggregate
    _min: PersonMinAggregate
}

type AggregateProject {
    _count: ProjectCountAggregate
    _max: ProjectMaxAggregate
    _min: ProjectMinAggregate
}

type AggregateProjectContributor {
    _count: ProjectContributorCountAggregate
    _max: ProjectContributorMaxAggregate
    _min: ProjectContributorMinAggregate
}

type AggregateSchool {
    _count: SchoolCountAggregate
    _max: SchoolMaxAggregate
    _min: SchoolMinAggregate
}

type AggregateTechnologyLogo {
    _count: TechnologyLogoCountAggregate
    _max: TechnologyLogoMaxAggregate
    _min: TechnologyLogoMinAggregate
}

type AggregateUser {
    _count: UserCountAggregate
    _max: UserMaxAggregate
    _min: UserMinAggregate
}

type Blog {
    _count: BlogCount!
    authors(cursor: BlogAuthorWhereUniqueInput, distinct: [BlogAuthorScalarFieldEnum!], orderBy: [BlogAuthorOrderByWithRelationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): [BlogAuthor!]!
    content: String!
    createdAt: DateTime!
    featuredImage: Image!
    id: String!
    imageId: String!
    slug: String!
    title: String!
    updatedAt: DateTime!
}

type BlogAuthor {
    author: Person!
    blog: Blog!
    blogId: String!
    createdAt: DateTime!
    id: String!
    personId: String!
    updatedAt: DateTime!
}

type BlogAuthorCountAggregate {
    _all: Int!
    blogId: Int!
    createdAt: Int!
    id: Int!
    personId: Int!
    updatedAt: Int!
}

type BlogAuthorGroupBy {
    _count: BlogAuthorCountAggregate
    _max: BlogAuthorMaxAggregate
    _min: BlogAuthorMinAggregate
    blogId: String!
    createdAt: DateTime!
    id: String!
    personId: String!
    updatedAt: DateTime!
}

type BlogAuthorMaxAggregate {
    blogId: String
    createdAt: DateTime
    id: String
    personId: String
    updatedAt: DateTime
}

type BlogAuthorMinAggregate {
    blogId: String
    createdAt: DateTime
    id: String
    personId: String
    updatedAt: DateTime
}

type BlogCount {
    authors: Int!
}

type BlogCountAggregate {
    _all: Int!
    content: Int!
    createdAt: Int!
    id: Int!
    imageId: Int!
    slug: Int!
    title: Int!
    updatedAt: Int!
}

type BlogGroupBy {
    _count: BlogCountAggregate
    _max: BlogMaxAggregate
    _min: BlogMinAggregate
    content: String!
    createdAt: DateTime!
    id: String!
    imageId: String!
    slug: String!
    title: String!
    updatedAt: DateTime!
}

type BlogMaxAggregate {
    content: String
    createdAt: DateTime
    id: String
    imageId: String
    slug: String
    title: String
    updatedAt: DateTime
}

type BlogMinAggregate {
    content: String
    createdAt: DateTime
    id: String
    imageId: String
    slug: String
    title: String
    updatedAt: DateTime
}

type Course {
    _count: CourseCount!
    complete: Boolean!
    courseUrls: [String!]!
    createdAt: DateTime!
    duration: Float!
    id: String!
    instructors(cursor: CourseInstructorWhereUniqueInput, distinct: [CourseInstructorScalarFieldEnum!], orderBy: [CourseInstructorOrderByWithRelationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): [CourseInstructor!]!
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    school: School!
    schoolId: String!
    title: String!
    updatedAt: DateTime!
    yearUpdated: Int!
}

type CourseAvgAggregate {
    duration: Float
    order: Float
    yearUpdated: Float
}

type CourseCount {
    instructors: Int!
}

type CourseCountAggregate {
    _all: Int!
    complete: Int!
    courseUrls: Int!
    createdAt: Int!
    duration: Int!
    id: Int!
    order: Int!
    rating: Int!
    ratingUrl: Int!
    recommended: Int!
    schoolId: Int!
    title: Int!
    updatedAt: Int!
    yearUpdated: Int!
}

type CourseGroupBy {
    _avg: CourseAvgAggregate
    _count: CourseCountAggregate
    _max: CourseMaxAggregate
    _min: CourseMinAggregate
    _sum: CourseSumAggregate
    complete: Boolean!
    courseUrls: [String!]
    createdAt: DateTime!
    duration: Float!
    id: String!
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    schoolId: String!
    title: String!
    updatedAt: DateTime!
    yearUpdated: Int!
}

type CourseInstructor {
    course: Course!
    courseId: String!
    createdAt: DateTime!
    id: String!
    instructor: Person!
    instructorId: String!
    updatedAt: DateTime!
}

type CourseInstructorCountAggregate {
    _all: Int!
    courseId: Int!
    createdAt: Int!
    id: Int!
    instructorId: Int!
    updatedAt: Int!
}

type CourseInstructorGroupBy {
    _count: CourseInstructorCountAggregate
    _max: CourseInstructorMaxAggregate
    _min: CourseInstructorMinAggregate
    courseId: String!
    createdAt: DateTime!
    id: String!
    instructorId: String!
    updatedAt: DateTime!
}

type CourseInstructorMaxAggregate {
    courseId: String
    createdAt: DateTime
    id: String
    instructorId: String
    updatedAt: DateTime
}

type CourseInstructorMinAggregate {
    courseId: String
    createdAt: DateTime
    id: String
    instructorId: String
    updatedAt: DateTime
}

type CourseMaxAggregate {
    complete: Boolean
    createdAt: DateTime
    duration: Float
    id: String
    order: Int
    rating: Rating
    ratingUrl: String
    recommended: Boolean
    schoolId: String
    title: String
    updatedAt: DateTime
    yearUpdated: Int
}

type CourseMinAggregate {
    complete: Boolean
    createdAt: DateTime
    duration: Float
    id: String
    order: Int
    rating: Rating
    ratingUrl: String
    recommended: Boolean
    schoolId: String
    title: String
    updatedAt: DateTime
    yearUpdated: Int
}

type CourseSumAggregate {
    duration: Float
    order: Int
    yearUpdated: Int
}

type Image {
    TechnologyLogos(cursor: TechnologyLogoWhereUniqueInput, distinct: [TechnologyLogoScalarFieldEnum!], orderBy: [TechnologyLogoOrderByWithRelationInput!], skip: Int, take: Int, where: TechnologyLogoWhereInput): [TechnologyLogo!]!
    _count: ImageCount!
    altText: String!
    blogs(cursor: BlogWhereUniqueInput, distinct: [BlogScalarFieldEnum!], orderBy: [BlogOrderByWithRelationInput!], skip: Int, take: Int, where: BlogWhereInput): [Blog!]!
    createdAt: DateTime!
    height: String!
    id: String!
    persons(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): [Person!]!
    projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
    schools(cursor: SchoolWhereUniqueInput, distinct: [SchoolScalarFieldEnum!], orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): [School!]!
    updatedAt: DateTime!
    url: String!
    width: String!
}

type ImageCount {
    TechnologyLogos: Int!
    blogs: Int!
    persons: Int!
    projects: Int!
    schools: Int!
}

type ImageCountAggregate {
    _all: Int!
    altText: Int!
    createdAt: Int!
    height: Int!
    id: Int!
    updatedAt: Int!
    url: Int!
    width: Int!
}

type ImageGroupBy {
    _count: ImageCountAggregate
    _max: ImageMaxAggregate
    _min: ImageMinAggregate
    altText: String!
    createdAt: DateTime!
    height: String!
    id: String!
    updatedAt: DateTime!
    url: String!
    width: String!
}

type ImageMaxAggregate {
    altText: String
    createdAt: DateTime
    height: String
    id: String
    updatedAt: DateTime
    url: String
    width: String
}

type ImageMinAggregate {
    altText: String
    createdAt: DateTime
    height: String
    id: String
    updatedAt: DateTime
    url: String
    width: String
}

type Mutation {
    createBlog(data: BlogCreateInput!): Blog!
    createBlogAuthor(data: BlogAuthorCreateInput!): BlogAuthor!
    createCourse(data: CourseCreateInput!): Course!
    createCourseInstructor(data: CourseInstructorCreateInput!): CourseInstructor!
    createImage(data: ImageCreateInput!): Image!
    createManyBlog(data: [BlogCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyBlogAuthor(data: [BlogAuthorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyCourse(data: [CourseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyCourseInstructor(data: [CourseInstructorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyImage(data: [ImageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyPerson(data: [PersonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyProject(data: [ProjectCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyProjectContributor(data: [ProjectContributorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManySchool(data: [SchoolCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyTechnologyLogo(data: [TechnologyLogoCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createPerson(data: PersonCreateInput!): Person!
    createProject(data: ProjectCreateInput!): Project!
    createProjectContributor(data: ProjectContributorCreateInput!): ProjectContributor!
    createSchool(data: SchoolCreateInput!): School!
    createTechnologyLogo(data: TechnologyLogoCreateInput!): TechnologyLogo!
    createUser(data: UserCreateInput!): User!
    deleteBlog(where: BlogWhereUniqueInput!): Blog
    deleteBlogAuthor(where: BlogAuthorWhereUniqueInput!): BlogAuthor
    deleteCourse(where: CourseWhereUniqueInput!): Course
    deleteCourseInstructor(where: CourseInstructorWhereUniqueInput!): CourseInstructor
    deleteImage(where: ImageWhereUniqueInput!): Image
    deleteManyBlog(where: BlogWhereInput): AffectedRowsOutput!
    deleteManyBlogAuthor(where: BlogAuthorWhereInput): AffectedRowsOutput!
    deleteManyCourse(where: CourseWhereInput): AffectedRowsOutput!
    deleteManyCourseInstructor(where: CourseInstructorWhereInput): AffectedRowsOutput!
    deleteManyImage(where: ImageWhereInput): AffectedRowsOutput!
    deleteManyPerson(where: PersonWhereInput): AffectedRowsOutput!
    deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
    deleteManyProjectContributor(where: ProjectContributorWhereInput): AffectedRowsOutput!
    deleteManySchool(where: SchoolWhereInput): AffectedRowsOutput!
    deleteManyTechnologyLogo(where: TechnologyLogoWhereInput): AffectedRowsOutput!
    deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
    deletePerson(where: PersonWhereUniqueInput!): Person
    deleteProject(where: ProjectWhereUniqueInput!): Project
    deleteProjectContributor(where: ProjectContributorWhereUniqueInput!): ProjectContributor
    deleteSchool(where: SchoolWhereUniqueInput!): School
    deleteTechnologyLogo(where: TechnologyLogoWhereUniqueInput!): TechnologyLogo
    deleteUser(where: UserWhereUniqueInput!): User
    updateBlog(data: BlogUpdateInput!, where: BlogWhereUniqueInput!): Blog
    updateBlogAuthor(data: BlogAuthorUpdateInput!, where: BlogAuthorWhereUniqueInput!): BlogAuthor
    updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
    updateCourseInstructor(data: CourseInstructorUpdateInput!, where: CourseInstructorWhereUniqueInput!): CourseInstructor
    updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
    updateManyBlog(data: BlogUpdateManyMutationInput!, where: BlogWhereInput): AffectedRowsOutput!
    updateManyBlogAuthor(data: BlogAuthorUpdateManyMutationInput!, where: BlogAuthorWhereInput): AffectedRowsOutput!
    updateManyCourse(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): AffectedRowsOutput!
    updateManyCourseInstructor(data: CourseInstructorUpdateManyMutationInput!, where: CourseInstructorWhereInput): AffectedRowsOutput!
    updateManyImage(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): AffectedRowsOutput!
    updateManyPerson(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): AffectedRowsOutput!
    updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): AffectedRowsOutput!
    updateManyProjectContributor(data: ProjectContributorUpdateManyMutationInput!, where: ProjectContributorWhereInput): AffectedRowsOutput!
    updateManySchool(data: SchoolUpdateManyMutationInput!, where: SchoolWhereInput): AffectedRowsOutput!
    updateManyTechnologyLogo(data: TechnologyLogoUpdateManyMutationInput!, where: TechnologyLogoWhereInput): AffectedRowsOutput!
    updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
    updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
    updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
    updateProjectContributor(data: ProjectContributorUpdateInput!, where: ProjectContributorWhereUniqueInput!): ProjectContributor
    updateSchool(data: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School
    updateTechnologyLogo(data: TechnologyLogoUpdateInput!, where: TechnologyLogoWhereUniqueInput!): TechnologyLogo
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    upsertBlog(create: BlogCreateInput!, update: BlogUpdateInput!, where: BlogWhereUniqueInput!): Blog!
    upsertBlogAuthor(create: BlogAuthorCreateInput!, update: BlogAuthorUpdateInput!, where: BlogAuthorWhereUniqueInput!): BlogAuthor!
    upsertCourse(create: CourseCreateInput!, update: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course!
    upsertCourseInstructor(create: CourseInstructorCreateInput!, update: CourseInstructorUpdateInput!, where: CourseInstructorWhereUniqueInput!): CourseInstructor!
    upsertImage(create: ImageCreateInput!, update: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image!
    upsertPerson(create: PersonCreateInput!, update: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person!
    upsertProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
    upsertProjectContributor(create: ProjectContributorCreateInput!, update: ProjectContributorUpdateInput!, where: ProjectContributorWhereUniqueInput!): ProjectContributor!
    upsertSchool(create: SchoolCreateInput!, update: SchoolUpdateInput!, where: SchoolWhereUniqueInput!): School!
    upsertTechnologyLogo(create: TechnologyLogoCreateInput!, update: TechnologyLogoUpdateInput!, where: TechnologyLogoWhereUniqueInput!): TechnologyLogo!
    upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

type Person {
    User(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
    _count: PersonCount!
    blogs(cursor: BlogAuthorWhereUniqueInput, distinct: [BlogAuthorScalarFieldEnum!], orderBy: [BlogAuthorOrderByWithRelationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): [BlogAuthor!]!
    courses(cursor: CourseInstructorWhereUniqueInput, distinct: [CourseInstructorScalarFieldEnum!], orderBy: [CourseInstructorOrderByWithRelationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): [CourseInstructor!]!
    createdAt: DateTime!
    firstName: String!
    githubUrl: String
    id: String!
    image: Image
    imageId: String
    lastName: String!
    linkedinUrl: String
    projects(cursor: ProjectContributorWhereUniqueInput, distinct: [ProjectContributorScalarFieldEnum!], orderBy: [ProjectContributorOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): [ProjectContributor!]!
    summary: String
    updatedAt: DateTime!
    websiteUrl: String
}

type PersonCount {
    User: Int!
    blogs: Int!
    courses: Int!
    projects: Int!
}

type PersonCountAggregate {
    _all: Int!
    createdAt: Int!
    firstName: Int!
    githubUrl: Int!
    id: Int!
    imageId: Int!
    lastName: Int!
    linkedinUrl: Int!
    summary: Int!
    updatedAt: Int!
    websiteUrl: Int!
}

type PersonGroupBy {
    _count: PersonCountAggregate
    _max: PersonMaxAggregate
    _min: PersonMinAggregate
    createdAt: DateTime!
    firstName: String!
    githubUrl: String
    id: String!
    imageId: String
    lastName: String!
    linkedinUrl: String
    summary: String
    updatedAt: DateTime!
    websiteUrl: String
}

type PersonMaxAggregate {
    createdAt: DateTime
    firstName: String
    githubUrl: String
    id: String
    imageId: String
    lastName: String
    linkedinUrl: String
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

type PersonMinAggregate {
    createdAt: DateTime
    firstName: String
    githubUrl: String
    id: String
    imageId: String
    lastName: String
    linkedinUrl: String
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

type Project {
    _count: ProjectCount!
    contributors(cursor: ProjectContributorWhereUniqueInput, distinct: [ProjectContributorScalarFieldEnum!], orderBy: [ProjectContributorOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): [ProjectContributor!]!
    createdAt: DateTime!
    featuredImage: Image!
    githubUrl: String
    id: String!
    imageId: String!
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime!
}

type ProjectContributor {
    contributor: Person!
    contributorId: String!
    createdAt: DateTime!
    id: String!
    project: Project!
    projectId: String!
    updatedAt: DateTime!
}

type ProjectContributorCountAggregate {
    _all: Int!
    contributorId: Int!
    createdAt: Int!
    id: Int!
    projectId: Int!
    updatedAt: Int!
}

type ProjectContributorGroupBy {
    _count: ProjectContributorCountAggregate
    _max: ProjectContributorMaxAggregate
    _min: ProjectContributorMinAggregate
    contributorId: String!
    createdAt: DateTime!
    id: String!
    projectId: String!
    updatedAt: DateTime!
}

type ProjectContributorMaxAggregate {
    contributorId: String
    createdAt: DateTime
    id: String
    projectId: String
    updatedAt: DateTime
}

type ProjectContributorMinAggregate {
    contributorId: String
    createdAt: DateTime
    id: String
    projectId: String
    updatedAt: DateTime
}

type ProjectCount {
    contributors: Int!
}

type ProjectCountAggregate {
    _all: Int!
    createdAt: Int!
    githubUrl: Int!
    id: Int!
    imageId: Int!
    name: Int!
    projectUrl: Int!
    slug: Int!
    summary: Int!
    updatedAt: Int!
}

type ProjectGroupBy {
    _count: ProjectCountAggregate
    _max: ProjectMaxAggregate
    _min: ProjectMinAggregate
    createdAt: DateTime!
    githubUrl: String
    id: String!
    imageId: String!
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime!
}

type ProjectMaxAggregate {
    createdAt: DateTime
    githubUrl: String
    id: String
    imageId: String
    name: String
    projectUrl: String
    slug: String
    summary: String
    updatedAt: DateTime
}

type ProjectMinAggregate {
    createdAt: DateTime
    githubUrl: String
    id: String
    imageId: String
    name: String
    projectUrl: String
    slug: String
    summary: String
    updatedAt: DateTime
}

type Query {
    aggregateBlog(cursor: BlogWhereUniqueInput, orderBy: [BlogOrderByWithRelationInput!], skip: Int, take: Int, where: BlogWhereInput): AggregateBlog!
    aggregateBlogAuthor(cursor: BlogAuthorWhereUniqueInput, orderBy: [BlogAuthorOrderByWithRelationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): AggregateBlogAuthor!
    aggregateCourse(cursor: CourseWhereUniqueInput, orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): AggregateCourse!
    aggregateCourseInstructor(cursor: CourseInstructorWhereUniqueInput, orderBy: [CourseInstructorOrderByWithRelationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): AggregateCourseInstructor!
    aggregateImage(cursor: ImageWhereUniqueInput, orderBy: [ImageOrderByWithRelationInput!], skip: Int, take: Int, where: ImageWhereInput): AggregateImage!
    aggregatePerson(cursor: PersonWhereUniqueInput, orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): AggregatePerson!
    aggregateProject(cursor: ProjectWhereUniqueInput, orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
    aggregateProjectContributor(cursor: ProjectContributorWhereUniqueInput, orderBy: [ProjectContributorOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): AggregateProjectContributor!
    aggregateSchool(cursor: SchoolWhereUniqueInput, orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): AggregateSchool!
    aggregateTechnologyLogo(cursor: TechnologyLogoWhereUniqueInput, orderBy: [TechnologyLogoOrderByWithRelationInput!], skip: Int, take: Int, where: TechnologyLogoWhereInput): AggregateTechnologyLogo!
    aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
    blog(where: BlogWhereUniqueInput!): Blog
    blogAuthor(where: BlogAuthorWhereUniqueInput!): BlogAuthor
    blogAuthors(cursor: BlogAuthorWhereUniqueInput, distinct: [BlogAuthorScalarFieldEnum!], orderBy: [BlogAuthorOrderByWithRelationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): [BlogAuthor!]!
    blogs(cursor: BlogWhereUniqueInput, distinct: [BlogScalarFieldEnum!], orderBy: [BlogOrderByWithRelationInput!], skip: Int, take: Int, where: BlogWhereInput): [Blog!]!
    course(where: CourseWhereUniqueInput!): Course
    courseInstructor(where: CourseInstructorWhereUniqueInput!): CourseInstructor
    courseInstructors(cursor: CourseInstructorWhereUniqueInput, distinct: [CourseInstructorScalarFieldEnum!], orderBy: [CourseInstructorOrderByWithRelationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): [CourseInstructor!]!
    courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
    findFirstBlog(cursor: BlogWhereUniqueInput, distinct: [BlogScalarFieldEnum!], orderBy: [BlogOrderByWithRelationInput!], skip: Int, take: Int, where: BlogWhereInput): Blog
    findFirstBlogAuthor(cursor: BlogAuthorWhereUniqueInput, distinct: [BlogAuthorScalarFieldEnum!], orderBy: [BlogAuthorOrderByWithRelationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): BlogAuthor
    findFirstCourse(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): Course
    findFirstCourseInstructor(cursor: CourseInstructorWhereUniqueInput, distinct: [CourseInstructorScalarFieldEnum!], orderBy: [CourseInstructorOrderByWithRelationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): CourseInstructor
    findFirstImage(cursor: ImageWhereUniqueInput, distinct: [ImageScalarFieldEnum!], orderBy: [ImageOrderByWithRelationInput!], skip: Int, take: Int, where: ImageWhereInput): Image
    findFirstPerson(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): Person
    findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
    findFirstProjectContributor(cursor: ProjectContributorWhereUniqueInput, distinct: [ProjectContributorScalarFieldEnum!], orderBy: [ProjectContributorOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): ProjectContributor
    findFirstSchool(cursor: SchoolWhereUniqueInput, distinct: [SchoolScalarFieldEnum!], orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): School
    findFirstTechnologyLogo(cursor: TechnologyLogoWhereUniqueInput, distinct: [TechnologyLogoScalarFieldEnum!], orderBy: [TechnologyLogoOrderByWithRelationInput!], skip: Int, take: Int, where: TechnologyLogoWhereInput): TechnologyLogo
    findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
    groupByBlog(by: [BlogScalarFieldEnum!]!, having: BlogScalarWhereWithAggregatesInput, orderBy: [BlogOrderByWithAggregationInput!], skip: Int, take: Int, where: BlogWhereInput): [BlogGroupBy!]!
    groupByBlogAuthor(by: [BlogAuthorScalarFieldEnum!]!, having: BlogAuthorScalarWhereWithAggregatesInput, orderBy: [BlogAuthorOrderByWithAggregationInput!], skip: Int, take: Int, where: BlogAuthorWhereInput): [BlogAuthorGroupBy!]!
    groupByCourse(by: [CourseScalarFieldEnum!]!, having: CourseScalarWhereWithAggregatesInput, orderBy: [CourseOrderByWithAggregationInput!], skip: Int, take: Int, where: CourseWhereInput): [CourseGroupBy!]!
    groupByCourseInstructor(by: [CourseInstructorScalarFieldEnum!]!, having: CourseInstructorScalarWhereWithAggregatesInput, orderBy: [CourseInstructorOrderByWithAggregationInput!], skip: Int, take: Int, where: CourseInstructorWhereInput): [CourseInstructorGroupBy!]!
    groupByImage(by: [ImageScalarFieldEnum!]!, having: ImageScalarWhereWithAggregatesInput, orderBy: [ImageOrderByWithAggregationInput!], skip: Int, take: Int, where: ImageWhereInput): [ImageGroupBy!]!
    groupByPerson(by: [PersonScalarFieldEnum!]!, having: PersonScalarWhereWithAggregatesInput, orderBy: [PersonOrderByWithAggregationInput!], skip: Int, take: Int, where: PersonWhereInput): [PersonGroupBy!]!
    groupByProject(by: [ProjectScalarFieldEnum!]!, having: ProjectScalarWhereWithAggregatesInput, orderBy: [ProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectWhereInput): [ProjectGroupBy!]!
    groupByProjectContributor(by: [ProjectContributorScalarFieldEnum!]!, having: ProjectContributorScalarWhereWithAggregatesInput, orderBy: [ProjectContributorOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): [ProjectContributorGroupBy!]!
    groupBySchool(by: [SchoolScalarFieldEnum!]!, having: SchoolScalarWhereWithAggregatesInput, orderBy: [SchoolOrderByWithAggregationInput!], skip: Int, take: Int, where: SchoolWhereInput): [SchoolGroupBy!]!
    groupByTechnologyLogo(by: [TechnologyLogoScalarFieldEnum!]!, having: TechnologyLogoScalarWhereWithAggregatesInput, orderBy: [TechnologyLogoOrderByWithAggregationInput!], skip: Int, take: Int, where: TechnologyLogoWhereInput): [TechnologyLogoGroupBy!]!
    groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
    image(where: ImageWhereUniqueInput!): Image
    images(cursor: ImageWhereUniqueInput, distinct: [ImageScalarFieldEnum!], orderBy: [ImageOrderByWithRelationInput!], skip: Int, take: Int, where: ImageWhereInput): [Image!]!
    people(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): [Person!]!
    person(where: PersonWhereUniqueInput!): Person
    project(where: ProjectWhereUniqueInput!): Project
    projectContributor(where: ProjectContributorWhereUniqueInput!): ProjectContributor
    projectContributors(cursor: ProjectContributorWhereUniqueInput, distinct: [ProjectContributorScalarFieldEnum!], orderBy: [ProjectContributorOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectContributorWhereInput): [ProjectContributor!]!
    projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
    school(where: SchoolWhereUniqueInput!): School
    schools(cursor: SchoolWhereUniqueInput, distinct: [SchoolScalarFieldEnum!], orderBy: [SchoolOrderByWithRelationInput!], skip: Int, take: Int, where: SchoolWhereInput): [School!]!
    technologyLogo(where: TechnologyLogoWhereUniqueInput!): TechnologyLogo
    technologyLogos(cursor: TechnologyLogoWhereUniqueInput, distinct: [TechnologyLogoScalarFieldEnum!], orderBy: [TechnologyLogoOrderByWithRelationInput!], skip: Int, take: Int, where: TechnologyLogoWhereInput): [TechnologyLogo!]!
    user(where: UserWhereUniqueInput!): User
    users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type School {
    _count: SchoolCount!
    courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
    createdAt: DateTime!
    description: String!
    id: String!
    imageId: String!
    logo: Image!
    name: String!
    updatedAt: DateTime!
    url: String!
}

type SchoolCount {
    courses: Int!
}

type SchoolCountAggregate {
    _all: Int!
    createdAt: Int!
    description: Int!
    id: Int!
    imageId: Int!
    name: Int!
    updatedAt: Int!
    url: Int!
}

type SchoolGroupBy {
    _count: SchoolCountAggregate
    _max: SchoolMaxAggregate
    _min: SchoolMinAggregate
    createdAt: DateTime!
    description: String!
    id: String!
    imageId: String!
    name: String!
    updatedAt: DateTime!
    url: String!
}

type SchoolMaxAggregate {
    createdAt: DateTime
    description: String
    id: String
    imageId: String
    name: String
    updatedAt: DateTime
    url: String
}

type SchoolMinAggregate {
    createdAt: DateTime
    description: String
    id: String
    imageId: String
    name: String
    updatedAt: DateTime
    url: String
}

type TechnologyLogo {
    createdAt: DateTime!
    id: String!
    imageId: String!
    isOnHomepage: Boolean!
    logo: Image!
    name: String!
    updatedAt: DateTime!
}

type TechnologyLogoCountAggregate {
    _all: Int!
    createdAt: Int!
    id: Int!
    imageId: Int!
    isOnHomepage: Int!
    name: Int!
    updatedAt: Int!
}

type TechnologyLogoGroupBy {
    _count: TechnologyLogoCountAggregate
    _max: TechnologyLogoMaxAggregate
    _min: TechnologyLogoMinAggregate
    createdAt: DateTime!
    id: String!
    imageId: String!
    isOnHomepage: Boolean!
    name: String!
    updatedAt: DateTime!
}

type TechnologyLogoMaxAggregate {
    createdAt: DateTime
    id: String
    imageId: String
    isOnHomepage: Boolean
    name: String
    updatedAt: DateTime
}

type TechnologyLogoMinAggregate {
    createdAt: DateTime
    id: String
    imageId: String
    isOnHomepage: Boolean
    name: String
    updatedAt: DateTime
}

type User {
    createdAt: DateTime!
    id: String!
    password: String!
    person: Person!
    personId: String!
    role: Role!
    updatedAt: DateTime!
    username: String!
}

type UserCountAggregate {
    _all: Int!
    createdAt: Int!
    id: Int!
    password: Int!
    personId: Int!
    role: Int!
    updatedAt: Int!
    username: Int!
}

type UserGroupBy {
    _count: UserCountAggregate
    _max: UserMaxAggregate
    _min: UserMinAggregate
    createdAt: DateTime!
    id: String!
    password: String!
    personId: String!
    role: Role!
    updatedAt: DateTime!
    username: String!
}

type UserMaxAggregate {
    createdAt: DateTime
    id: String
    password: String
    personId: String
    role: Role
    updatedAt: DateTime
    username: String
}

type UserMinAggregate {
    createdAt: DateTime
    id: String
    password: String
    personId: String
    role: Role
    updatedAt: DateTime
    username: String
}

enum BlogAuthorScalarFieldEnum {
    blogId
    createdAt
    id
    personId
    updatedAt
}

enum BlogScalarFieldEnum {
    content
    createdAt
    id
    imageId
    slug
    title
    updatedAt
}

enum CourseInstructorScalarFieldEnum {
    courseId
    createdAt
    id
    instructorId
    updatedAt
}

enum CourseScalarFieldEnum {
    complete
    courseUrls
    createdAt
    duration
    id
    order
    rating
    ratingUrl
    recommended
    schoolId
    title
    updatedAt
    yearUpdated
}

enum ImageScalarFieldEnum {
    altText
    createdAt
    height
    id
    updatedAt
    url
    width
}

enum PersonScalarFieldEnum {
    createdAt
    firstName
    githubUrl
    id
    imageId
    lastName
    linkedinUrl
    summary
    updatedAt
    websiteUrl
}

enum ProjectContributorScalarFieldEnum {
    contributorId
    createdAt
    id
    projectId
    updatedAt
}

enum ProjectScalarFieldEnum {
    createdAt
    githubUrl
    id
    imageId
    name
    projectUrl
    slug
    summary
    updatedAt
}

enum QueryMode {
    default
    insensitive
}

enum Rating {
    FIVE
    FOUR
    ONE
    THREE
    TWO
}

enum Role {
    ADMIN
    USER
}

enum SchoolScalarFieldEnum {
    createdAt
    description
    id
    imageId
    name
    updatedAt
    url
}

enum SortOrder {
    asc
    desc
}

enum TechnologyLogoScalarFieldEnum {
    createdAt
    id
    imageId
    isOnHomepage
    name
    updatedAt
}

enum UserScalarFieldEnum {
    createdAt
    id
    password
    personId
    role
    updatedAt
    username
}

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar DateTime

input BlogAuthorCountOrderByAggregateInput {
    blogId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input BlogAuthorCreateInput {
    author: PersonCreateNestedOneWithoutBlogsInput!
    blog: BlogCreateNestedOneWithoutAuthorsInput!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input BlogAuthorCreateManyAuthorInput {
    blogId: String!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input BlogAuthorCreateManyAuthorInputEnvelope {
    data: [BlogAuthorCreateManyAuthorInput!]!
    skipDuplicates: Boolean
}

input BlogAuthorCreateManyBlogInput {
    createdAt: DateTime
    id: String
    personId: String!
    updatedAt: DateTime
}

input BlogAuthorCreateManyBlogInputEnvelope {
    data: [BlogAuthorCreateManyBlogInput!]!
    skipDuplicates: Boolean
}

input BlogAuthorCreateManyInput {
    blogId: String!
    createdAt: DateTime
    id: String
    personId: String!
    updatedAt: DateTime
}

input BlogAuthorCreateNestedManyWithoutAuthorInput {
    connect: [BlogAuthorWhereUniqueInput!]
    connectOrCreate: [BlogAuthorCreateOrConnectWithoutAuthorInput!]
    create: [BlogAuthorCreateWithoutAuthorInput!]
    createMany: BlogAuthorCreateManyAuthorInputEnvelope
}

input BlogAuthorCreateNestedManyWithoutBlogInput {
    connect: [BlogAuthorWhereUniqueInput!]
    connectOrCreate: [BlogAuthorCreateOrConnectWithoutBlogInput!]
    create: [BlogAuthorCreateWithoutBlogInput!]
    createMany: BlogAuthorCreateManyBlogInputEnvelope
}

input BlogAuthorCreateOrConnectWithoutAuthorInput {
    create: BlogAuthorCreateWithoutAuthorInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorCreateOrConnectWithoutBlogInput {
    create: BlogAuthorCreateWithoutBlogInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorCreateWithoutAuthorInput {
    blog: BlogCreateNestedOneWithoutAuthorsInput!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input BlogAuthorCreateWithoutBlogInput {
    author: PersonCreateNestedOneWithoutBlogsInput!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input BlogAuthorListRelationFilter {
    every: BlogAuthorWhereInput
    none: BlogAuthorWhereInput
    some: BlogAuthorWhereInput
}

input BlogAuthorMaxOrderByAggregateInput {
    blogId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input BlogAuthorMinOrderByAggregateInput {
    blogId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input BlogAuthorOrderByRelationAggregateInput {
    _count: SortOrder
}

input BlogAuthorOrderByWithAggregationInput {
    _count: BlogAuthorCountOrderByAggregateInput
    _max: BlogAuthorMaxOrderByAggregateInput
    _min: BlogAuthorMinOrderByAggregateInput
    blogId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input BlogAuthorOrderByWithRelationInput {
    author: PersonOrderByWithRelationInput
    blog: BlogOrderByWithRelationInput
    blogId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input BlogAuthorScalarWhereInput {
    AND: [BlogAuthorScalarWhereInput!]
    NOT: [BlogAuthorScalarWhereInput!]
    OR: [BlogAuthorScalarWhereInput!]
    blogId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    personId: StringFilter
    updatedAt: DateTimeFilter
}

input BlogAuthorScalarWhereWithAggregatesInput {
    AND: [BlogAuthorScalarWhereWithAggregatesInput!]
    NOT: [BlogAuthorScalarWhereWithAggregatesInput!]
    OR: [BlogAuthorScalarWhereWithAggregatesInput!]
    blogId: StringWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    personId: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input BlogAuthorUpdateInput {
    author: PersonUpdateOneRequiredWithoutBlogsInput
    blog: BlogUpdateOneRequiredWithoutAuthorsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogAuthorUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogAuthorUpdateManyWithWhereWithoutAuthorInput {
    data: BlogAuthorUpdateManyMutationInput!
    where: BlogAuthorScalarWhereInput!
}

input BlogAuthorUpdateManyWithWhereWithoutBlogInput {
    data: BlogAuthorUpdateManyMutationInput!
    where: BlogAuthorScalarWhereInput!
}

input BlogAuthorUpdateManyWithoutAuthorInput {
    connect: [BlogAuthorWhereUniqueInput!]
    connectOrCreate: [BlogAuthorCreateOrConnectWithoutAuthorInput!]
    create: [BlogAuthorCreateWithoutAuthorInput!]
    createMany: BlogAuthorCreateManyAuthorInputEnvelope
    delete: [BlogAuthorWhereUniqueInput!]
    deleteMany: [BlogAuthorScalarWhereInput!]
    disconnect: [BlogAuthorWhereUniqueInput!]
    set: [BlogAuthorWhereUniqueInput!]
    update: [BlogAuthorUpdateWithWhereUniqueWithoutAuthorInput!]
    updateMany: [BlogAuthorUpdateManyWithWhereWithoutAuthorInput!]
    upsert: [BlogAuthorUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogAuthorUpdateManyWithoutBlogInput {
    connect: [BlogAuthorWhereUniqueInput!]
    connectOrCreate: [BlogAuthorCreateOrConnectWithoutBlogInput!]
    create: [BlogAuthorCreateWithoutBlogInput!]
    createMany: BlogAuthorCreateManyBlogInputEnvelope
    delete: [BlogAuthorWhereUniqueInput!]
    deleteMany: [BlogAuthorScalarWhereInput!]
    disconnect: [BlogAuthorWhereUniqueInput!]
    set: [BlogAuthorWhereUniqueInput!]
    update: [BlogAuthorUpdateWithWhereUniqueWithoutBlogInput!]
    updateMany: [BlogAuthorUpdateManyWithWhereWithoutBlogInput!]
    upsert: [BlogAuthorUpsertWithWhereUniqueWithoutBlogInput!]
}

input BlogAuthorUpdateWithWhereUniqueWithoutAuthorInput {
    data: BlogAuthorUpdateWithoutAuthorInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorUpdateWithWhereUniqueWithoutBlogInput {
    data: BlogAuthorUpdateWithoutBlogInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorUpdateWithoutAuthorInput {
    blog: BlogUpdateOneRequiredWithoutAuthorsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogAuthorUpdateWithoutBlogInput {
    author: PersonUpdateOneRequiredWithoutBlogsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogAuthorUpsertWithWhereUniqueWithoutAuthorInput {
    create: BlogAuthorCreateWithoutAuthorInput!
    update: BlogAuthorUpdateWithoutAuthorInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorUpsertWithWhereUniqueWithoutBlogInput {
    create: BlogAuthorCreateWithoutBlogInput!
    update: BlogAuthorUpdateWithoutBlogInput!
    where: BlogAuthorWhereUniqueInput!
}

input BlogAuthorWhereInput {
    AND: [BlogAuthorWhereInput!]
    NOT: [BlogAuthorWhereInput!]
    OR: [BlogAuthorWhereInput!]
    author: PersonRelationFilter
    blog: BlogRelationFilter
    blogId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    personId: StringFilter
    updatedAt: DateTimeFilter
}

input BlogAuthorWhereUniqueInput {
    id: String
}

input BlogCountOrderByAggregateInput {
    content: SortOrder
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    slug: SortOrder
    title: SortOrder
    updatedAt: SortOrder
}

input BlogCreateInput {
    authors: BlogAuthorCreateNestedManyWithoutBlogInput
    content: String!
    createdAt: DateTime
    featuredImage: ImageCreateNestedOneWithoutBlogsInput!
    id: String
    slug: String!
    title: String!
    updatedAt: DateTime
}

input BlogCreateManyFeaturedImageInput {
    content: String!
    createdAt: DateTime
    id: String
    slug: String!
    title: String!
    updatedAt: DateTime
}

input BlogCreateManyFeaturedImageInputEnvelope {
    data: [BlogCreateManyFeaturedImageInput!]!
    skipDuplicates: Boolean
}

input BlogCreateManyInput {
    content: String!
    createdAt: DateTime
    id: String
    imageId: String!
    slug: String!
    title: String!
    updatedAt: DateTime
}

input BlogCreateNestedManyWithoutFeaturedImageInput {
    connect: [BlogWhereUniqueInput!]
    connectOrCreate: [BlogCreateOrConnectWithoutFeaturedImageInput!]
    create: [BlogCreateWithoutFeaturedImageInput!]
    createMany: BlogCreateManyFeaturedImageInputEnvelope
}

input BlogCreateNestedOneWithoutAuthorsInput {
    connect: BlogWhereUniqueInput
    connectOrCreate: BlogCreateOrConnectWithoutAuthorsInput
    create: BlogCreateWithoutAuthorsInput
}

input BlogCreateOrConnectWithoutAuthorsInput {
    create: BlogCreateWithoutAuthorsInput!
    where: BlogWhereUniqueInput!
}

input BlogCreateOrConnectWithoutFeaturedImageInput {
    create: BlogCreateWithoutFeaturedImageInput!
    where: BlogWhereUniqueInput!
}

input BlogCreateWithoutAuthorsInput {
    content: String!
    createdAt: DateTime
    featuredImage: ImageCreateNestedOneWithoutBlogsInput!
    id: String
    slug: String!
    title: String!
    updatedAt: DateTime
}

input BlogCreateWithoutFeaturedImageInput {
    authors: BlogAuthorCreateNestedManyWithoutBlogInput
    content: String!
    createdAt: DateTime
    id: String
    slug: String!
    title: String!
    updatedAt: DateTime
}

input BlogListRelationFilter {
    every: BlogWhereInput
    none: BlogWhereInput
    some: BlogWhereInput
}

input BlogMaxOrderByAggregateInput {
    content: SortOrder
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    slug: SortOrder
    title: SortOrder
    updatedAt: SortOrder
}

input BlogMinOrderByAggregateInput {
    content: SortOrder
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    slug: SortOrder
    title: SortOrder
    updatedAt: SortOrder
}

input BlogOrderByRelationAggregateInput {
    _count: SortOrder
}

input BlogOrderByWithAggregationInput {
    _count: BlogCountOrderByAggregateInput
    _max: BlogMaxOrderByAggregateInput
    _min: BlogMinOrderByAggregateInput
    content: SortOrder
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    slug: SortOrder
    title: SortOrder
    updatedAt: SortOrder
}

input BlogOrderByWithRelationInput {
    authors: BlogAuthorOrderByRelationAggregateInput
    content: SortOrder
    createdAt: SortOrder
    featuredImage: ImageOrderByWithRelationInput
    id: SortOrder
    imageId: SortOrder
    slug: SortOrder
    title: SortOrder
    updatedAt: SortOrder
}

input BlogRelationFilter {
    is: BlogWhereInput
    isNot: BlogWhereInput
}

input BlogScalarWhereInput {
    AND: [BlogScalarWhereInput!]
    NOT: [BlogScalarWhereInput!]
    OR: [BlogScalarWhereInput!]
    content: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    imageId: StringFilter
    slug: StringFilter
    title: StringFilter
    updatedAt: DateTimeFilter
}

input BlogScalarWhereWithAggregatesInput {
    AND: [BlogScalarWhereWithAggregatesInput!]
    NOT: [BlogScalarWhereWithAggregatesInput!]
    OR: [BlogScalarWhereWithAggregatesInput!]
    content: StringWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    imageId: StringWithAggregatesFilter
    slug: StringWithAggregatesFilter
    title: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input BlogUpdateInput {
    authors: BlogAuthorUpdateManyWithoutBlogInput
    content: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    featuredImage: ImageUpdateOneRequiredWithoutBlogsInput
    id: StringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogUpdateManyMutationInput {
    content: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogUpdateManyWithWhereWithoutFeaturedImageInput {
    data: BlogUpdateManyMutationInput!
    where: BlogScalarWhereInput!
}

input BlogUpdateManyWithoutFeaturedImageInput {
    connect: [BlogWhereUniqueInput!]
    connectOrCreate: [BlogCreateOrConnectWithoutFeaturedImageInput!]
    create: [BlogCreateWithoutFeaturedImageInput!]
    createMany: BlogCreateManyFeaturedImageInputEnvelope
    delete: [BlogWhereUniqueInput!]
    deleteMany: [BlogScalarWhereInput!]
    disconnect: [BlogWhereUniqueInput!]
    set: [BlogWhereUniqueInput!]
    update: [BlogUpdateWithWhereUniqueWithoutFeaturedImageInput!]
    updateMany: [BlogUpdateManyWithWhereWithoutFeaturedImageInput!]
    upsert: [BlogUpsertWithWhereUniqueWithoutFeaturedImageInput!]
}

input BlogUpdateOneRequiredWithoutAuthorsInput {
    connect: BlogWhereUniqueInput
    connectOrCreate: BlogCreateOrConnectWithoutAuthorsInput
    create: BlogCreateWithoutAuthorsInput
    update: BlogUpdateWithoutAuthorsInput
    upsert: BlogUpsertWithoutAuthorsInput
}

input BlogUpdateWithWhereUniqueWithoutFeaturedImageInput {
    data: BlogUpdateWithoutFeaturedImageInput!
    where: BlogWhereUniqueInput!
}

input BlogUpdateWithoutAuthorsInput {
    content: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    featuredImage: ImageUpdateOneRequiredWithoutBlogsInput
    id: StringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogUpdateWithoutFeaturedImageInput {
    authors: BlogAuthorUpdateManyWithoutBlogInput
    content: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input BlogUpsertWithWhereUniqueWithoutFeaturedImageInput {
    create: BlogCreateWithoutFeaturedImageInput!
    update: BlogUpdateWithoutFeaturedImageInput!
    where: BlogWhereUniqueInput!
}

input BlogUpsertWithoutAuthorsInput {
    create: BlogCreateWithoutAuthorsInput!
    update: BlogUpdateWithoutAuthorsInput!
}

input BlogWhereInput {
    AND: [BlogWhereInput!]
    NOT: [BlogWhereInput!]
    OR: [BlogWhereInput!]
    authors: BlogAuthorListRelationFilter
    content: StringFilter
    createdAt: DateTimeFilter
    featuredImage: ImageRelationFilter
    id: StringFilter
    imageId: StringFilter
    slug: StringFilter
    title: StringFilter
    updatedAt: DateTimeFilter
}

input BlogWhereUniqueInput {
    id: String
    slug: String
}

input BoolFieldUpdateOperationsInput {
    set: Boolean
}

input BoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

input CourseAvgOrderByAggregateInput {
    duration: SortOrder
    order: SortOrder
    yearUpdated: SortOrder
}

input CourseCountOrderByAggregateInput {
    complete: SortOrder
    courseUrls: SortOrder
    createdAt: SortOrder
    duration: SortOrder
    id: SortOrder
    order: SortOrder
    rating: SortOrder
    ratingUrl: SortOrder
    recommended: SortOrder
    schoolId: SortOrder
    title: SortOrder
    updatedAt: SortOrder
    yearUpdated: SortOrder
}

input CourseCreateInput {
    complete: Boolean!
    courseUrls: CourseCreatecourseUrlsInput
    createdAt: DateTime
    duration: Float!
    id: String
    instructors: CourseInstructorCreateNestedManyWithoutCourseInput
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    school: SchoolCreateNestedOneWithoutCoursesInput!
    title: String!
    updatedAt: DateTime
    yearUpdated: Int!
}

input CourseCreateManyInput {
    complete: Boolean!
    courseUrls: CourseCreateManycourseUrlsInput
    createdAt: DateTime
    duration: Float!
    id: String
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    schoolId: String!
    title: String!
    updatedAt: DateTime
    yearUpdated: Int!
}

input CourseCreateManySchoolInput {
    complete: Boolean!
    courseUrls: CourseCreateManycourseUrlsInput
    createdAt: DateTime
    duration: Float!
    id: String
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    title: String!
    updatedAt: DateTime
    yearUpdated: Int!
}

input CourseCreateManySchoolInputEnvelope {
    data: [CourseCreateManySchoolInput!]!
    skipDuplicates: Boolean
}

input CourseCreateManycourseUrlsInput {
    set: [String!]!
}

input CourseCreateNestedManyWithoutSchoolInput {
    connect: [CourseWhereUniqueInput!]
    connectOrCreate: [CourseCreateOrConnectWithoutSchoolInput!]
    create: [CourseCreateWithoutSchoolInput!]
    createMany: CourseCreateManySchoolInputEnvelope
}

input CourseCreateNestedOneWithoutInstructorsInput {
    connect: CourseWhereUniqueInput
    connectOrCreate: CourseCreateOrConnectWithoutInstructorsInput
    create: CourseCreateWithoutInstructorsInput
}

input CourseCreateOrConnectWithoutInstructorsInput {
    create: CourseCreateWithoutInstructorsInput!
    where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutSchoolInput {
    create: CourseCreateWithoutSchoolInput!
    where: CourseWhereUniqueInput!
}

input CourseCreateWithoutInstructorsInput {
    complete: Boolean!
    courseUrls: CourseCreatecourseUrlsInput
    createdAt: DateTime
    duration: Float!
    id: String
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    school: SchoolCreateNestedOneWithoutCoursesInput!
    title: String!
    updatedAt: DateTime
    yearUpdated: Int!
}

input CourseCreateWithoutSchoolInput {
    complete: Boolean!
    courseUrls: CourseCreatecourseUrlsInput
    createdAt: DateTime
    duration: Float!
    id: String
    instructors: CourseInstructorCreateNestedManyWithoutCourseInput
    order: Int!
    rating: Rating
    ratingUrl: String
    recommended: Boolean!
    title: String!
    updatedAt: DateTime
    yearUpdated: Int!
}

input CourseCreatecourseUrlsInput {
    set: [String!]!
}

input CourseInstructorCountOrderByAggregateInput {
    courseId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    instructorId: SortOrder
    updatedAt: SortOrder
}

input CourseInstructorCreateInput {
    course: CourseCreateNestedOneWithoutInstructorsInput!
    createdAt: DateTime
    id: String
    instructor: PersonCreateNestedOneWithoutCoursesInput!
    updatedAt: DateTime
}

input CourseInstructorCreateManyCourseInput {
    createdAt: DateTime
    id: String
    instructorId: String!
    updatedAt: DateTime
}

input CourseInstructorCreateManyCourseInputEnvelope {
    data: [CourseInstructorCreateManyCourseInput!]!
    skipDuplicates: Boolean
}

input CourseInstructorCreateManyInput {
    courseId: String!
    createdAt: DateTime
    id: String
    instructorId: String!
    updatedAt: DateTime
}

input CourseInstructorCreateManyInstructorInput {
    courseId: String!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input CourseInstructorCreateManyInstructorInputEnvelope {
    data: [CourseInstructorCreateManyInstructorInput!]!
    skipDuplicates: Boolean
}

input CourseInstructorCreateNestedManyWithoutCourseInput {
    connect: [CourseInstructorWhereUniqueInput!]
    connectOrCreate: [CourseInstructorCreateOrConnectWithoutCourseInput!]
    create: [CourseInstructorCreateWithoutCourseInput!]
    createMany: CourseInstructorCreateManyCourseInputEnvelope
}

input CourseInstructorCreateNestedManyWithoutInstructorInput {
    connect: [CourseInstructorWhereUniqueInput!]
    connectOrCreate: [CourseInstructorCreateOrConnectWithoutInstructorInput!]
    create: [CourseInstructorCreateWithoutInstructorInput!]
    createMany: CourseInstructorCreateManyInstructorInputEnvelope
}

input CourseInstructorCreateOrConnectWithoutCourseInput {
    create: CourseInstructorCreateWithoutCourseInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorCreateOrConnectWithoutInstructorInput {
    create: CourseInstructorCreateWithoutInstructorInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorCreateWithoutCourseInput {
    createdAt: DateTime
    id: String
    instructor: PersonCreateNestedOneWithoutCoursesInput!
    updatedAt: DateTime
}

input CourseInstructorCreateWithoutInstructorInput {
    course: CourseCreateNestedOneWithoutInstructorsInput!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input CourseInstructorListRelationFilter {
    every: CourseInstructorWhereInput
    none: CourseInstructorWhereInput
    some: CourseInstructorWhereInput
}

input CourseInstructorMaxOrderByAggregateInput {
    courseId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    instructorId: SortOrder
    updatedAt: SortOrder
}

input CourseInstructorMinOrderByAggregateInput {
    courseId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    instructorId: SortOrder
    updatedAt: SortOrder
}

input CourseInstructorOrderByRelationAggregateInput {
    _count: SortOrder
}

input CourseInstructorOrderByWithAggregationInput {
    _count: CourseInstructorCountOrderByAggregateInput
    _max: CourseInstructorMaxOrderByAggregateInput
    _min: CourseInstructorMinOrderByAggregateInput
    courseId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    instructorId: SortOrder
    updatedAt: SortOrder
}

input CourseInstructorOrderByWithRelationInput {
    course: CourseOrderByWithRelationInput
    courseId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    instructor: PersonOrderByWithRelationInput
    instructorId: SortOrder
    updatedAt: SortOrder
}

input CourseInstructorScalarWhereInput {
    AND: [CourseInstructorScalarWhereInput!]
    NOT: [CourseInstructorScalarWhereInput!]
    OR: [CourseInstructorScalarWhereInput!]
    courseId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    instructorId: StringFilter
    updatedAt: DateTimeFilter
}

input CourseInstructorScalarWhereWithAggregatesInput {
    AND: [CourseInstructorScalarWhereWithAggregatesInput!]
    NOT: [CourseInstructorScalarWhereWithAggregatesInput!]
    OR: [CourseInstructorScalarWhereWithAggregatesInput!]
    courseId: StringWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    instructorId: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input CourseInstructorUpdateInput {
    course: CourseUpdateOneRequiredWithoutInstructorsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    instructor: PersonUpdateOneRequiredWithoutCoursesInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseInstructorUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseInstructorUpdateManyWithWhereWithoutCourseInput {
    data: CourseInstructorUpdateManyMutationInput!
    where: CourseInstructorScalarWhereInput!
}

input CourseInstructorUpdateManyWithWhereWithoutInstructorInput {
    data: CourseInstructorUpdateManyMutationInput!
    where: CourseInstructorScalarWhereInput!
}

input CourseInstructorUpdateManyWithoutCourseInput {
    connect: [CourseInstructorWhereUniqueInput!]
    connectOrCreate: [CourseInstructorCreateOrConnectWithoutCourseInput!]
    create: [CourseInstructorCreateWithoutCourseInput!]
    createMany: CourseInstructorCreateManyCourseInputEnvelope
    delete: [CourseInstructorWhereUniqueInput!]
    deleteMany: [CourseInstructorScalarWhereInput!]
    disconnect: [CourseInstructorWhereUniqueInput!]
    set: [CourseInstructorWhereUniqueInput!]
    update: [CourseInstructorUpdateWithWhereUniqueWithoutCourseInput!]
    updateMany: [CourseInstructorUpdateManyWithWhereWithoutCourseInput!]
    upsert: [CourseInstructorUpsertWithWhereUniqueWithoutCourseInput!]
}

input CourseInstructorUpdateManyWithoutInstructorInput {
    connect: [CourseInstructorWhereUniqueInput!]
    connectOrCreate: [CourseInstructorCreateOrConnectWithoutInstructorInput!]
    create: [CourseInstructorCreateWithoutInstructorInput!]
    createMany: CourseInstructorCreateManyInstructorInputEnvelope
    delete: [CourseInstructorWhereUniqueInput!]
    deleteMany: [CourseInstructorScalarWhereInput!]
    disconnect: [CourseInstructorWhereUniqueInput!]
    set: [CourseInstructorWhereUniqueInput!]
    update: [CourseInstructorUpdateWithWhereUniqueWithoutInstructorInput!]
    updateMany: [CourseInstructorUpdateManyWithWhereWithoutInstructorInput!]
    upsert: [CourseInstructorUpsertWithWhereUniqueWithoutInstructorInput!]
}

input CourseInstructorUpdateWithWhereUniqueWithoutCourseInput {
    data: CourseInstructorUpdateWithoutCourseInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorUpdateWithWhereUniqueWithoutInstructorInput {
    data: CourseInstructorUpdateWithoutInstructorInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorUpdateWithoutCourseInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    instructor: PersonUpdateOneRequiredWithoutCoursesInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseInstructorUpdateWithoutInstructorInput {
    course: CourseUpdateOneRequiredWithoutInstructorsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseInstructorUpsertWithWhereUniqueWithoutCourseInput {
    create: CourseInstructorCreateWithoutCourseInput!
    update: CourseInstructorUpdateWithoutCourseInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorUpsertWithWhereUniqueWithoutInstructorInput {
    create: CourseInstructorCreateWithoutInstructorInput!
    update: CourseInstructorUpdateWithoutInstructorInput!
    where: CourseInstructorWhereUniqueInput!
}

input CourseInstructorWhereInput {
    AND: [CourseInstructorWhereInput!]
    NOT: [CourseInstructorWhereInput!]
    OR: [CourseInstructorWhereInput!]
    course: CourseRelationFilter
    courseId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    instructor: PersonRelationFilter
    instructorId: StringFilter
    updatedAt: DateTimeFilter
}

input CourseInstructorWhereUniqueInput {
    id: String
}

input CourseListRelationFilter {
    every: CourseWhereInput
    none: CourseWhereInput
    some: CourseWhereInput
}

input CourseMaxOrderByAggregateInput {
    complete: SortOrder
    createdAt: SortOrder
    duration: SortOrder
    id: SortOrder
    order: SortOrder
    rating: SortOrder
    ratingUrl: SortOrder
    recommended: SortOrder
    schoolId: SortOrder
    title: SortOrder
    updatedAt: SortOrder
    yearUpdated: SortOrder
}

input CourseMinOrderByAggregateInput {
    complete: SortOrder
    createdAt: SortOrder
    duration: SortOrder
    id: SortOrder
    order: SortOrder
    rating: SortOrder
    ratingUrl: SortOrder
    recommended: SortOrder
    schoolId: SortOrder
    title: SortOrder
    updatedAt: SortOrder
    yearUpdated: SortOrder
}

input CourseOrderByRelationAggregateInput {
    _count: SortOrder
}

input CourseOrderByWithAggregationInput {
    _avg: CourseAvgOrderByAggregateInput
    _count: CourseCountOrderByAggregateInput
    _max: CourseMaxOrderByAggregateInput
    _min: CourseMinOrderByAggregateInput
    _sum: CourseSumOrderByAggregateInput
    complete: SortOrder
    courseUrls: SortOrder
    createdAt: SortOrder
    duration: SortOrder
    id: SortOrder
    order: SortOrder
    rating: SortOrder
    ratingUrl: SortOrder
    recommended: SortOrder
    schoolId: SortOrder
    title: SortOrder
    updatedAt: SortOrder
    yearUpdated: SortOrder
}

input CourseOrderByWithRelationInput {
    complete: SortOrder
    courseUrls: SortOrder
    createdAt: SortOrder
    duration: SortOrder
    id: SortOrder
    instructors: CourseInstructorOrderByRelationAggregateInput
    order: SortOrder
    rating: SortOrder
    ratingUrl: SortOrder
    recommended: SortOrder
    school: SchoolOrderByWithRelationInput
    schoolId: SortOrder
    title: SortOrder
    updatedAt: SortOrder
    yearUpdated: SortOrder
}

input CourseRelationFilter {
    is: CourseWhereInput
    isNot: CourseWhereInput
}

input CourseScalarWhereInput {
    AND: [CourseScalarWhereInput!]
    NOT: [CourseScalarWhereInput!]
    OR: [CourseScalarWhereInput!]
    complete: BoolFilter
    courseUrls: StringNullableListFilter
    createdAt: DateTimeFilter
    duration: FloatFilter
    id: StringFilter
    order: IntFilter
    rating: EnumRatingNullableFilter
    ratingUrl: StringNullableFilter
    recommended: BoolFilter
    schoolId: StringFilter
    title: StringFilter
    updatedAt: DateTimeFilter
    yearUpdated: IntFilter
}

input CourseScalarWhereWithAggregatesInput {
    AND: [CourseScalarWhereWithAggregatesInput!]
    NOT: [CourseScalarWhereWithAggregatesInput!]
    OR: [CourseScalarWhereWithAggregatesInput!]
    complete: BoolWithAggregatesFilter
    courseUrls: StringNullableListFilter
    createdAt: DateTimeWithAggregatesFilter
    duration: FloatWithAggregatesFilter
    id: StringWithAggregatesFilter
    order: IntWithAggregatesFilter
    rating: EnumRatingNullableWithAggregatesFilter
    ratingUrl: StringNullableWithAggregatesFilter
    recommended: BoolWithAggregatesFilter
    schoolId: StringWithAggregatesFilter
    title: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    yearUpdated: IntWithAggregatesFilter
}

input CourseSumOrderByAggregateInput {
    duration: SortOrder
    order: SortOrder
    yearUpdated: SortOrder
}

input CourseUpdateInput {
    complete: BoolFieldUpdateOperationsInput
    courseUrls: CourseUpdatecourseUrlsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    duration: FloatFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    instructors: CourseInstructorUpdateManyWithoutCourseInput
    order: IntFieldUpdateOperationsInput
    rating: NullableEnumRatingFieldUpdateOperationsInput
    ratingUrl: NullableStringFieldUpdateOperationsInput
    recommended: BoolFieldUpdateOperationsInput
    school: SchoolUpdateOneRequiredWithoutCoursesInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    yearUpdated: IntFieldUpdateOperationsInput
}

input CourseUpdateManyMutationInput {
    complete: BoolFieldUpdateOperationsInput
    courseUrls: CourseUpdatecourseUrlsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    duration: FloatFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    order: IntFieldUpdateOperationsInput
    rating: NullableEnumRatingFieldUpdateOperationsInput
    ratingUrl: NullableStringFieldUpdateOperationsInput
    recommended: BoolFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    yearUpdated: IntFieldUpdateOperationsInput
}

input CourseUpdateManyWithWhereWithoutSchoolInput {
    data: CourseUpdateManyMutationInput!
    where: CourseScalarWhereInput!
}

input CourseUpdateManyWithoutSchoolInput {
    connect: [CourseWhereUniqueInput!]
    connectOrCreate: [CourseCreateOrConnectWithoutSchoolInput!]
    create: [CourseCreateWithoutSchoolInput!]
    createMany: CourseCreateManySchoolInputEnvelope
    delete: [CourseWhereUniqueInput!]
    deleteMany: [CourseScalarWhereInput!]
    disconnect: [CourseWhereUniqueInput!]
    set: [CourseWhereUniqueInput!]
    update: [CourseUpdateWithWhereUniqueWithoutSchoolInput!]
    updateMany: [CourseUpdateManyWithWhereWithoutSchoolInput!]
    upsert: [CourseUpsertWithWhereUniqueWithoutSchoolInput!]
}

input CourseUpdateOneRequiredWithoutInstructorsInput {
    connect: CourseWhereUniqueInput
    connectOrCreate: CourseCreateOrConnectWithoutInstructorsInput
    create: CourseCreateWithoutInstructorsInput
    update: CourseUpdateWithoutInstructorsInput
    upsert: CourseUpsertWithoutInstructorsInput
}

input CourseUpdateWithWhereUniqueWithoutSchoolInput {
    data: CourseUpdateWithoutSchoolInput!
    where: CourseWhereUniqueInput!
}

input CourseUpdateWithoutInstructorsInput {
    complete: BoolFieldUpdateOperationsInput
    courseUrls: CourseUpdatecourseUrlsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    duration: FloatFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    order: IntFieldUpdateOperationsInput
    rating: NullableEnumRatingFieldUpdateOperationsInput
    ratingUrl: NullableStringFieldUpdateOperationsInput
    recommended: BoolFieldUpdateOperationsInput
    school: SchoolUpdateOneRequiredWithoutCoursesInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    yearUpdated: IntFieldUpdateOperationsInput
}

input CourseUpdateWithoutSchoolInput {
    complete: BoolFieldUpdateOperationsInput
    courseUrls: CourseUpdatecourseUrlsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    duration: FloatFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    instructors: CourseInstructorUpdateManyWithoutCourseInput
    order: IntFieldUpdateOperationsInput
    rating: NullableEnumRatingFieldUpdateOperationsInput
    ratingUrl: NullableStringFieldUpdateOperationsInput
    recommended: BoolFieldUpdateOperationsInput
    title: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    yearUpdated: IntFieldUpdateOperationsInput
}

input CourseUpdatecourseUrlsInput {
    push: [String!]
    set: [String!]
}

input CourseUpsertWithWhereUniqueWithoutSchoolInput {
    create: CourseCreateWithoutSchoolInput!
    update: CourseUpdateWithoutSchoolInput!
    where: CourseWhereUniqueInput!
}

input CourseUpsertWithoutInstructorsInput {
    create: CourseCreateWithoutInstructorsInput!
    update: CourseUpdateWithoutInstructorsInput!
}

input CourseWhereInput {
    AND: [CourseWhereInput!]
    NOT: [CourseWhereInput!]
    OR: [CourseWhereInput!]
    complete: BoolFilter
    courseUrls: StringNullableListFilter
    createdAt: DateTimeFilter
    duration: FloatFilter
    id: StringFilter
    instructors: CourseInstructorListRelationFilter
    order: IntFilter
    rating: EnumRatingNullableFilter
    ratingUrl: StringNullableFilter
    recommended: BoolFilter
    school: SchoolRelationFilter
    schoolId: StringFilter
    title: StringFilter
    updatedAt: DateTimeFilter
    yearUpdated: IntFilter
}

input CourseWhereUniqueInput {
    id: String
}

input DateTimeFieldUpdateOperationsInput {
    set: DateTime
}

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

input EnumRatingNullableFilter {
    equals: Rating
    in: [Rating!]
    not: NestedEnumRatingNullableFilter
    notIn: [Rating!]
}

input EnumRatingNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedEnumRatingNullableFilter
    _min: NestedEnumRatingNullableFilter
    equals: Rating
    in: [Rating!]
    not: NestedEnumRatingNullableWithAggregatesFilter
    notIn: [Rating!]
}

input EnumRoleFieldUpdateOperationsInput {
    set: Role
}

input EnumRoleFilter {
    equals: Role
    in: [Role!]
    not: NestedEnumRoleFilter
    notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRoleFilter
    _min: NestedEnumRoleFilter
    equals: Role
    in: [Role!]
    not: NestedEnumRoleWithAggregatesFilter
    notIn: [Role!]
}

input FloatFieldUpdateOperationsInput {
    decrement: Float
    divide: Float
    increment: Float
    multiply: Float
    set: Float
}

input FloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatFilter
    notIn: [Float!]
}

input FloatWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedFloatFilter
    _min: NestedFloatFilter
    _sum: NestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input ImageCountOrderByAggregateInput {
    altText: SortOrder
    createdAt: SortOrder
    height: SortOrder
    id: SortOrder
    updatedAt: SortOrder
    url: SortOrder
    width: SortOrder
}

input ImageCreateInput {
    TechnologyLogos: TechnologyLogoCreateNestedManyWithoutLogoInput
    altText: String!
    blogs: BlogCreateNestedManyWithoutFeaturedImageInput
    createdAt: DateTime
    height: String!
    id: String
    persons: PersonCreateNestedManyWithoutImageInput
    projects: ProjectCreateNestedManyWithoutFeaturedImageInput
    schools: SchoolCreateNestedManyWithoutLogoInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateManyInput {
    altText: String!
    createdAt: DateTime
    height: String!
    id: String
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateNestedOneWithoutBlogsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutBlogsInput
    create: ImageCreateWithoutBlogsInput
}

input ImageCreateNestedOneWithoutPersonsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutPersonsInput
    create: ImageCreateWithoutPersonsInput
}

input ImageCreateNestedOneWithoutProjectsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutProjectsInput
    create: ImageCreateWithoutProjectsInput
}

input ImageCreateNestedOneWithoutSchoolsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutSchoolsInput
    create: ImageCreateWithoutSchoolsInput
}

input ImageCreateNestedOneWithoutTechnologyLogosInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutTechnologyLogosInput
    create: ImageCreateWithoutTechnologyLogosInput
}

input ImageCreateOrConnectWithoutBlogsInput {
    create: ImageCreateWithoutBlogsInput!
    where: ImageWhereUniqueInput!
}

input ImageCreateOrConnectWithoutPersonsInput {
    create: ImageCreateWithoutPersonsInput!
    where: ImageWhereUniqueInput!
}

input ImageCreateOrConnectWithoutProjectsInput {
    create: ImageCreateWithoutProjectsInput!
    where: ImageWhereUniqueInput!
}

input ImageCreateOrConnectWithoutSchoolsInput {
    create: ImageCreateWithoutSchoolsInput!
    where: ImageWhereUniqueInput!
}

input ImageCreateOrConnectWithoutTechnologyLogosInput {
    create: ImageCreateWithoutTechnologyLogosInput!
    where: ImageWhereUniqueInput!
}

input ImageCreateWithoutBlogsInput {
    TechnologyLogos: TechnologyLogoCreateNestedManyWithoutLogoInput
    altText: String!
    createdAt: DateTime
    height: String!
    id: String
    persons: PersonCreateNestedManyWithoutImageInput
    projects: ProjectCreateNestedManyWithoutFeaturedImageInput
    schools: SchoolCreateNestedManyWithoutLogoInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateWithoutPersonsInput {
    TechnologyLogos: TechnologyLogoCreateNestedManyWithoutLogoInput
    altText: String!
    blogs: BlogCreateNestedManyWithoutFeaturedImageInput
    createdAt: DateTime
    height: String!
    id: String
    projects: ProjectCreateNestedManyWithoutFeaturedImageInput
    schools: SchoolCreateNestedManyWithoutLogoInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateWithoutProjectsInput {
    TechnologyLogos: TechnologyLogoCreateNestedManyWithoutLogoInput
    altText: String!
    blogs: BlogCreateNestedManyWithoutFeaturedImageInput
    createdAt: DateTime
    height: String!
    id: String
    persons: PersonCreateNestedManyWithoutImageInput
    schools: SchoolCreateNestedManyWithoutLogoInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateWithoutSchoolsInput {
    TechnologyLogos: TechnologyLogoCreateNestedManyWithoutLogoInput
    altText: String!
    blogs: BlogCreateNestedManyWithoutFeaturedImageInput
    createdAt: DateTime
    height: String!
    id: String
    persons: PersonCreateNestedManyWithoutImageInput
    projects: ProjectCreateNestedManyWithoutFeaturedImageInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageCreateWithoutTechnologyLogosInput {
    altText: String!
    blogs: BlogCreateNestedManyWithoutFeaturedImageInput
    createdAt: DateTime
    height: String!
    id: String
    persons: PersonCreateNestedManyWithoutImageInput
    projects: ProjectCreateNestedManyWithoutFeaturedImageInput
    schools: SchoolCreateNestedManyWithoutLogoInput
    updatedAt: DateTime
    url: String!
    width: String!
}

input ImageMaxOrderByAggregateInput {
    altText: SortOrder
    createdAt: SortOrder
    height: SortOrder
    id: SortOrder
    updatedAt: SortOrder
    url: SortOrder
    width: SortOrder
}

input ImageMinOrderByAggregateInput {
    altText: SortOrder
    createdAt: SortOrder
    height: SortOrder
    id: SortOrder
    updatedAt: SortOrder
    url: SortOrder
    width: SortOrder
}

input ImageOrderByWithAggregationInput {
    _count: ImageCountOrderByAggregateInput
    _max: ImageMaxOrderByAggregateInput
    _min: ImageMinOrderByAggregateInput
    altText: SortOrder
    createdAt: SortOrder
    height: SortOrder
    id: SortOrder
    updatedAt: SortOrder
    url: SortOrder
    width: SortOrder
}

input ImageOrderByWithRelationInput {
    TechnologyLogos: TechnologyLogoOrderByRelationAggregateInput
    altText: SortOrder
    blogs: BlogOrderByRelationAggregateInput
    createdAt: SortOrder
    height: SortOrder
    id: SortOrder
    persons: PersonOrderByRelationAggregateInput
    projects: ProjectOrderByRelationAggregateInput
    schools: SchoolOrderByRelationAggregateInput
    updatedAt: SortOrder
    url: SortOrder
    width: SortOrder
}

input ImageRelationFilter {
    is: ImageWhereInput
    isNot: ImageWhereInput
}

input ImageScalarWhereWithAggregatesInput {
    AND: [ImageScalarWhereWithAggregatesInput!]
    NOT: [ImageScalarWhereWithAggregatesInput!]
    OR: [ImageScalarWhereWithAggregatesInput!]
    altText: StringWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    height: StringWithAggregatesFilter
    id: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    url: StringWithAggregatesFilter
    width: StringWithAggregatesFilter
}

input ImageUpdateInput {
    TechnologyLogos: TechnologyLogoUpdateManyWithoutLogoInput
    altText: StringFieldUpdateOperationsInput
    blogs: BlogUpdateManyWithoutFeaturedImageInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    persons: PersonUpdateManyWithoutImageInput
    projects: ProjectUpdateManyWithoutFeaturedImageInput
    schools: SchoolUpdateManyWithoutLogoInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateManyMutationInput {
    altText: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateOneRequiredWithoutBlogsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutBlogsInput
    create: ImageCreateWithoutBlogsInput
    update: ImageUpdateWithoutBlogsInput
    upsert: ImageUpsertWithoutBlogsInput
}

input ImageUpdateOneRequiredWithoutProjectsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutProjectsInput
    create: ImageCreateWithoutProjectsInput
    update: ImageUpdateWithoutProjectsInput
    upsert: ImageUpsertWithoutProjectsInput
}

input ImageUpdateOneRequiredWithoutSchoolsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutSchoolsInput
    create: ImageCreateWithoutSchoolsInput
    update: ImageUpdateWithoutSchoolsInput
    upsert: ImageUpsertWithoutSchoolsInput
}

input ImageUpdateOneRequiredWithoutTechnologyLogosInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutTechnologyLogosInput
    create: ImageCreateWithoutTechnologyLogosInput
    update: ImageUpdateWithoutTechnologyLogosInput
    upsert: ImageUpsertWithoutTechnologyLogosInput
}

input ImageUpdateOneWithoutPersonsInput {
    connect: ImageWhereUniqueInput
    connectOrCreate: ImageCreateOrConnectWithoutPersonsInput
    create: ImageCreateWithoutPersonsInput
    delete: Boolean
    disconnect: Boolean
    update: ImageUpdateWithoutPersonsInput
    upsert: ImageUpsertWithoutPersonsInput
}

input ImageUpdateWithoutBlogsInput {
    TechnologyLogos: TechnologyLogoUpdateManyWithoutLogoInput
    altText: StringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    persons: PersonUpdateManyWithoutImageInput
    projects: ProjectUpdateManyWithoutFeaturedImageInput
    schools: SchoolUpdateManyWithoutLogoInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateWithoutPersonsInput {
    TechnologyLogos: TechnologyLogoUpdateManyWithoutLogoInput
    altText: StringFieldUpdateOperationsInput
    blogs: BlogUpdateManyWithoutFeaturedImageInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    projects: ProjectUpdateManyWithoutFeaturedImageInput
    schools: SchoolUpdateManyWithoutLogoInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateWithoutProjectsInput {
    TechnologyLogos: TechnologyLogoUpdateManyWithoutLogoInput
    altText: StringFieldUpdateOperationsInput
    blogs: BlogUpdateManyWithoutFeaturedImageInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    persons: PersonUpdateManyWithoutImageInput
    schools: SchoolUpdateManyWithoutLogoInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateWithoutSchoolsInput {
    TechnologyLogos: TechnologyLogoUpdateManyWithoutLogoInput
    altText: StringFieldUpdateOperationsInput
    blogs: BlogUpdateManyWithoutFeaturedImageInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    persons: PersonUpdateManyWithoutImageInput
    projects: ProjectUpdateManyWithoutFeaturedImageInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpdateWithoutTechnologyLogosInput {
    altText: StringFieldUpdateOperationsInput
    blogs: BlogUpdateManyWithoutFeaturedImageInput
    createdAt: DateTimeFieldUpdateOperationsInput
    height: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    persons: PersonUpdateManyWithoutImageInput
    projects: ProjectUpdateManyWithoutFeaturedImageInput
    schools: SchoolUpdateManyWithoutLogoInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
    width: StringFieldUpdateOperationsInput
}

input ImageUpsertWithoutBlogsInput {
    create: ImageCreateWithoutBlogsInput!
    update: ImageUpdateWithoutBlogsInput!
}

input ImageUpsertWithoutPersonsInput {
    create: ImageCreateWithoutPersonsInput!
    update: ImageUpdateWithoutPersonsInput!
}

input ImageUpsertWithoutProjectsInput {
    create: ImageCreateWithoutProjectsInput!
    update: ImageUpdateWithoutProjectsInput!
}

input ImageUpsertWithoutSchoolsInput {
    create: ImageCreateWithoutSchoolsInput!
    update: ImageUpdateWithoutSchoolsInput!
}

input ImageUpsertWithoutTechnologyLogosInput {
    create: ImageCreateWithoutTechnologyLogosInput!
    update: ImageUpdateWithoutTechnologyLogosInput!
}

input ImageWhereInput {
    AND: [ImageWhereInput!]
    NOT: [ImageWhereInput!]
    OR: [ImageWhereInput!]
    TechnologyLogos: TechnologyLogoListRelationFilter
    altText: StringFilter
    blogs: BlogListRelationFilter
    createdAt: DateTimeFilter
    height: StringFilter
    id: StringFilter
    persons: PersonListRelationFilter
    projects: ProjectListRelationFilter
    schools: SchoolListRelationFilter
    updatedAt: DateTimeFilter
    url: StringFilter
    width: StringFilter
}

input ImageWhereUniqueInput {
    id: String
    url: String
}

input IntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input IntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input NestedBoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

input NestedEnumRatingNullableFilter {
    equals: Rating
    in: [Rating!]
    not: NestedEnumRatingNullableFilter
    notIn: [Rating!]
}

input NestedEnumRatingNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedEnumRatingNullableFilter
    _min: NestedEnumRatingNullableFilter
    equals: Rating
    in: [Rating!]
    not: NestedEnumRatingNullableWithAggregatesFilter
    notIn: [Rating!]
}

input NestedEnumRoleFilter {
    equals: Role
    in: [Role!]
    not: NestedEnumRoleFilter
    notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumRoleFilter
    _min: NestedEnumRoleFilter
    equals: Role
    in: [Role!]
    not: NestedEnumRoleWithAggregatesFilter
    notIn: [Role!]
}

input NestedFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatFilter
    notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedFloatFilter
    _min: NestedFloatFilter
    _sum: NestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input NestedIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input NestedIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableFilter
    notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input NestedStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input NullableEnumRatingFieldUpdateOperationsInput {
    set: Rating
}

input NullableStringFieldUpdateOperationsInput {
    set: String
}

input PersonCountOrderByAggregateInput {
    createdAt: SortOrder
    firstName: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    lastName: SortOrder
    linkedinUrl: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
    websiteUrl: SortOrder
}

input PersonCreateInput {
    User: UserCreateNestedManyWithoutPersonInput
    blogs: BlogAuthorCreateNestedManyWithoutAuthorInput
    courses: CourseInstructorCreateNestedManyWithoutInstructorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    image: ImageCreateNestedOneWithoutPersonsInput
    lastName: String!
    linkedinUrl: String
    projects: ProjectContributorCreateNestedManyWithoutContributorInput
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateManyImageInput {
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    lastName: String!
    linkedinUrl: String
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateManyImageInputEnvelope {
    data: [PersonCreateManyImageInput!]!
    skipDuplicates: Boolean
}

input PersonCreateManyInput {
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    imageId: String
    lastName: String!
    linkedinUrl: String
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateNestedManyWithoutImageInput {
    connect: [PersonWhereUniqueInput!]
    connectOrCreate: [PersonCreateOrConnectWithoutImageInput!]
    create: [PersonCreateWithoutImageInput!]
    createMany: PersonCreateManyImageInputEnvelope
}

input PersonCreateNestedOneWithoutBlogsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutBlogsInput
    create: PersonCreateWithoutBlogsInput
}

input PersonCreateNestedOneWithoutCoursesInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutCoursesInput
    create: PersonCreateWithoutCoursesInput
}

input PersonCreateNestedOneWithoutProjectsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutProjectsInput
    create: PersonCreateWithoutProjectsInput
}

input PersonCreateNestedOneWithoutUserInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutUserInput
    create: PersonCreateWithoutUserInput
}

input PersonCreateOrConnectWithoutBlogsInput {
    create: PersonCreateWithoutBlogsInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutCoursesInput {
    create: PersonCreateWithoutCoursesInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutImageInput {
    create: PersonCreateWithoutImageInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutProjectsInput {
    create: PersonCreateWithoutProjectsInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutUserInput {
    create: PersonCreateWithoutUserInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateWithoutBlogsInput {
    User: UserCreateNestedManyWithoutPersonInput
    courses: CourseInstructorCreateNestedManyWithoutInstructorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    image: ImageCreateNestedOneWithoutPersonsInput
    lastName: String!
    linkedinUrl: String
    projects: ProjectContributorCreateNestedManyWithoutContributorInput
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateWithoutCoursesInput {
    User: UserCreateNestedManyWithoutPersonInput
    blogs: BlogAuthorCreateNestedManyWithoutAuthorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    image: ImageCreateNestedOneWithoutPersonsInput
    lastName: String!
    linkedinUrl: String
    projects: ProjectContributorCreateNestedManyWithoutContributorInput
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateWithoutImageInput {
    User: UserCreateNestedManyWithoutPersonInput
    blogs: BlogAuthorCreateNestedManyWithoutAuthorInput
    courses: CourseInstructorCreateNestedManyWithoutInstructorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    lastName: String!
    linkedinUrl: String
    projects: ProjectContributorCreateNestedManyWithoutContributorInput
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateWithoutProjectsInput {
    User: UserCreateNestedManyWithoutPersonInput
    blogs: BlogAuthorCreateNestedManyWithoutAuthorInput
    courses: CourseInstructorCreateNestedManyWithoutInstructorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    image: ImageCreateNestedOneWithoutPersonsInput
    lastName: String!
    linkedinUrl: String
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonCreateWithoutUserInput {
    blogs: BlogAuthorCreateNestedManyWithoutAuthorInput
    courses: CourseInstructorCreateNestedManyWithoutInstructorInput
    createdAt: DateTime
    firstName: String!
    githubUrl: String
    id: String
    image: ImageCreateNestedOneWithoutPersonsInput
    lastName: String!
    linkedinUrl: String
    projects: ProjectContributorCreateNestedManyWithoutContributorInput
    summary: String
    updatedAt: DateTime
    websiteUrl: String
}

input PersonListRelationFilter {
    every: PersonWhereInput
    none: PersonWhereInput
    some: PersonWhereInput
}

input PersonMaxOrderByAggregateInput {
    createdAt: SortOrder
    firstName: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    lastName: SortOrder
    linkedinUrl: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
    websiteUrl: SortOrder
}

input PersonMinOrderByAggregateInput {
    createdAt: SortOrder
    firstName: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    lastName: SortOrder
    linkedinUrl: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
    websiteUrl: SortOrder
}

input PersonOrderByRelationAggregateInput {
    _count: SortOrder
}

input PersonOrderByWithAggregationInput {
    _count: PersonCountOrderByAggregateInput
    _max: PersonMaxOrderByAggregateInput
    _min: PersonMinOrderByAggregateInput
    createdAt: SortOrder
    firstName: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    lastName: SortOrder
    linkedinUrl: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
    websiteUrl: SortOrder
}

input PersonOrderByWithRelationInput {
    User: UserOrderByRelationAggregateInput
    blogs: BlogAuthorOrderByRelationAggregateInput
    courses: CourseInstructorOrderByRelationAggregateInput
    createdAt: SortOrder
    firstName: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    image: ImageOrderByWithRelationInput
    imageId: SortOrder
    lastName: SortOrder
    linkedinUrl: SortOrder
    projects: ProjectContributorOrderByRelationAggregateInput
    summary: SortOrder
    updatedAt: SortOrder
    websiteUrl: SortOrder
}

input PersonRelationFilter {
    is: PersonWhereInput
    isNot: PersonWhereInput
}

input PersonScalarWhereInput {
    AND: [PersonScalarWhereInput!]
    NOT: [PersonScalarWhereInput!]
    OR: [PersonScalarWhereInput!]
    createdAt: DateTimeFilter
    firstName: StringFilter
    githubUrl: StringNullableFilter
    id: StringFilter
    imageId: StringNullableFilter
    lastName: StringFilter
    linkedinUrl: StringNullableFilter
    summary: StringNullableFilter
    updatedAt: DateTimeFilter
    websiteUrl: StringNullableFilter
}

input PersonScalarWhereWithAggregatesInput {
    AND: [PersonScalarWhereWithAggregatesInput!]
    NOT: [PersonScalarWhereWithAggregatesInput!]
    OR: [PersonScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    firstName: StringWithAggregatesFilter
    githubUrl: StringNullableWithAggregatesFilter
    id: StringWithAggregatesFilter
    imageId: StringNullableWithAggregatesFilter
    lastName: StringWithAggregatesFilter
    linkedinUrl: StringNullableWithAggregatesFilter
    summary: StringNullableWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    websiteUrl: StringNullableWithAggregatesFilter
}

input PersonUpdateInput {
    User: UserUpdateManyWithoutPersonInput
    blogs: BlogAuthorUpdateManyWithoutAuthorInput
    courses: CourseInstructorUpdateManyWithoutInstructorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    image: ImageUpdateOneWithoutPersonsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    projects: ProjectContributorUpdateManyWithoutContributorInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateManyWithWhereWithoutImageInput {
    data: PersonUpdateManyMutationInput!
    where: PersonScalarWhereInput!
}

input PersonUpdateManyWithoutImageInput {
    connect: [PersonWhereUniqueInput!]
    connectOrCreate: [PersonCreateOrConnectWithoutImageInput!]
    create: [PersonCreateWithoutImageInput!]
    createMany: PersonCreateManyImageInputEnvelope
    delete: [PersonWhereUniqueInput!]
    deleteMany: [PersonScalarWhereInput!]
    disconnect: [PersonWhereUniqueInput!]
    set: [PersonWhereUniqueInput!]
    update: [PersonUpdateWithWhereUniqueWithoutImageInput!]
    updateMany: [PersonUpdateManyWithWhereWithoutImageInput!]
    upsert: [PersonUpsertWithWhereUniqueWithoutImageInput!]
}

input PersonUpdateOneRequiredWithoutBlogsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutBlogsInput
    create: PersonCreateWithoutBlogsInput
    update: PersonUpdateWithoutBlogsInput
    upsert: PersonUpsertWithoutBlogsInput
}

input PersonUpdateOneRequiredWithoutCoursesInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutCoursesInput
    create: PersonCreateWithoutCoursesInput
    update: PersonUpdateWithoutCoursesInput
    upsert: PersonUpsertWithoutCoursesInput
}

input PersonUpdateOneRequiredWithoutProjectsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutProjectsInput
    create: PersonCreateWithoutProjectsInput
    update: PersonUpdateWithoutProjectsInput
    upsert: PersonUpsertWithoutProjectsInput
}

input PersonUpdateOneRequiredWithoutUserInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutUserInput
    create: PersonCreateWithoutUserInput
    update: PersonUpdateWithoutUserInput
    upsert: PersonUpsertWithoutUserInput
}

input PersonUpdateWithWhereUniqueWithoutImageInput {
    data: PersonUpdateWithoutImageInput!
    where: PersonWhereUniqueInput!
}

input PersonUpdateWithoutBlogsInput {
    User: UserUpdateManyWithoutPersonInput
    courses: CourseInstructorUpdateManyWithoutInstructorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    image: ImageUpdateOneWithoutPersonsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    projects: ProjectContributorUpdateManyWithoutContributorInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateWithoutCoursesInput {
    User: UserUpdateManyWithoutPersonInput
    blogs: BlogAuthorUpdateManyWithoutAuthorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    image: ImageUpdateOneWithoutPersonsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    projects: ProjectContributorUpdateManyWithoutContributorInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateWithoutImageInput {
    User: UserUpdateManyWithoutPersonInput
    blogs: BlogAuthorUpdateManyWithoutAuthorInput
    courses: CourseInstructorUpdateManyWithoutInstructorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    projects: ProjectContributorUpdateManyWithoutContributorInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateWithoutProjectsInput {
    User: UserUpdateManyWithoutPersonInput
    blogs: BlogAuthorUpdateManyWithoutAuthorInput
    courses: CourseInstructorUpdateManyWithoutInstructorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    image: ImageUpdateOneWithoutPersonsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpdateWithoutUserInput {
    blogs: BlogAuthorUpdateManyWithoutAuthorInput
    courses: CourseInstructorUpdateManyWithoutInstructorInput
    createdAt: DateTimeFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    image: ImageUpdateOneWithoutPersonsInput
    lastName: StringFieldUpdateOperationsInput
    linkedinUrl: NullableStringFieldUpdateOperationsInput
    projects: ProjectContributorUpdateManyWithoutContributorInput
    summary: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    websiteUrl: NullableStringFieldUpdateOperationsInput
}

input PersonUpsertWithWhereUniqueWithoutImageInput {
    create: PersonCreateWithoutImageInput!
    update: PersonUpdateWithoutImageInput!
    where: PersonWhereUniqueInput!
}

input PersonUpsertWithoutBlogsInput {
    create: PersonCreateWithoutBlogsInput!
    update: PersonUpdateWithoutBlogsInput!
}

input PersonUpsertWithoutCoursesInput {
    create: PersonCreateWithoutCoursesInput!
    update: PersonUpdateWithoutCoursesInput!
}

input PersonUpsertWithoutProjectsInput {
    create: PersonCreateWithoutProjectsInput!
    update: PersonUpdateWithoutProjectsInput!
}

input PersonUpsertWithoutUserInput {
    create: PersonCreateWithoutUserInput!
    update: PersonUpdateWithoutUserInput!
}

input PersonWhereInput {
    AND: [PersonWhereInput!]
    NOT: [PersonWhereInput!]
    OR: [PersonWhereInput!]
    User: UserListRelationFilter
    blogs: BlogAuthorListRelationFilter
    courses: CourseInstructorListRelationFilter
    createdAt: DateTimeFilter
    firstName: StringFilter
    githubUrl: StringNullableFilter
    id: StringFilter
    image: ImageRelationFilter
    imageId: StringNullableFilter
    lastName: StringFilter
    linkedinUrl: StringNullableFilter
    projects: ProjectContributorListRelationFilter
    summary: StringNullableFilter
    updatedAt: DateTimeFilter
    websiteUrl: StringNullableFilter
}

input PersonWhereUniqueInput {
    id: String
}

input ProjectContributorCountOrderByAggregateInput {
    contributorId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    projectId: SortOrder
    updatedAt: SortOrder
}

input ProjectContributorCreateInput {
    contributor: PersonCreateNestedOneWithoutProjectsInput!
    createdAt: DateTime
    id: String
    project: ProjectCreateNestedOneWithoutContributorsInput!
    updatedAt: DateTime
}

input ProjectContributorCreateManyContributorInput {
    createdAt: DateTime
    id: String
    projectId: String!
    updatedAt: DateTime
}

input ProjectContributorCreateManyContributorInputEnvelope {
    data: [ProjectContributorCreateManyContributorInput!]!
    skipDuplicates: Boolean
}

input ProjectContributorCreateManyInput {
    contributorId: String!
    createdAt: DateTime
    id: String
    projectId: String!
    updatedAt: DateTime
}

input ProjectContributorCreateManyProjectInput {
    contributorId: String!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input ProjectContributorCreateManyProjectInputEnvelope {
    data: [ProjectContributorCreateManyProjectInput!]!
    skipDuplicates: Boolean
}

input ProjectContributorCreateNestedManyWithoutContributorInput {
    connect: [ProjectContributorWhereUniqueInput!]
    connectOrCreate: [ProjectContributorCreateOrConnectWithoutContributorInput!]
    create: [ProjectContributorCreateWithoutContributorInput!]
    createMany: ProjectContributorCreateManyContributorInputEnvelope
}

input ProjectContributorCreateNestedManyWithoutProjectInput {
    connect: [ProjectContributorWhereUniqueInput!]
    connectOrCreate: [ProjectContributorCreateOrConnectWithoutProjectInput!]
    create: [ProjectContributorCreateWithoutProjectInput!]
    createMany: ProjectContributorCreateManyProjectInputEnvelope
}

input ProjectContributorCreateOrConnectWithoutContributorInput {
    create: ProjectContributorCreateWithoutContributorInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorCreateOrConnectWithoutProjectInput {
    create: ProjectContributorCreateWithoutProjectInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorCreateWithoutContributorInput {
    createdAt: DateTime
    id: String
    project: ProjectCreateNestedOneWithoutContributorsInput!
    updatedAt: DateTime
}

input ProjectContributorCreateWithoutProjectInput {
    contributor: PersonCreateNestedOneWithoutProjectsInput!
    createdAt: DateTime
    id: String
    updatedAt: DateTime
}

input ProjectContributorListRelationFilter {
    every: ProjectContributorWhereInput
    none: ProjectContributorWhereInput
    some: ProjectContributorWhereInput
}

input ProjectContributorMaxOrderByAggregateInput {
    contributorId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    projectId: SortOrder
    updatedAt: SortOrder
}

input ProjectContributorMinOrderByAggregateInput {
    contributorId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    projectId: SortOrder
    updatedAt: SortOrder
}

input ProjectContributorOrderByRelationAggregateInput {
    _count: SortOrder
}

input ProjectContributorOrderByWithAggregationInput {
    _count: ProjectContributorCountOrderByAggregateInput
    _max: ProjectContributorMaxOrderByAggregateInput
    _min: ProjectContributorMinOrderByAggregateInput
    contributorId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    projectId: SortOrder
    updatedAt: SortOrder
}

input ProjectContributorOrderByWithRelationInput {
    contributor: PersonOrderByWithRelationInput
    contributorId: SortOrder
    createdAt: SortOrder
    id: SortOrder
    project: ProjectOrderByWithRelationInput
    projectId: SortOrder
    updatedAt: SortOrder
}

input ProjectContributorScalarWhereInput {
    AND: [ProjectContributorScalarWhereInput!]
    NOT: [ProjectContributorScalarWhereInput!]
    OR: [ProjectContributorScalarWhereInput!]
    contributorId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    projectId: StringFilter
    updatedAt: DateTimeFilter
}

input ProjectContributorScalarWhereWithAggregatesInput {
    AND: [ProjectContributorScalarWhereWithAggregatesInput!]
    NOT: [ProjectContributorScalarWhereWithAggregatesInput!]
    OR: [ProjectContributorScalarWhereWithAggregatesInput!]
    contributorId: StringWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    projectId: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input ProjectContributorUpdateInput {
    contributor: PersonUpdateOneRequiredWithoutProjectsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    project: ProjectUpdateOneRequiredWithoutContributorsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectContributorUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectContributorUpdateManyWithWhereWithoutContributorInput {
    data: ProjectContributorUpdateManyMutationInput!
    where: ProjectContributorScalarWhereInput!
}

input ProjectContributorUpdateManyWithWhereWithoutProjectInput {
    data: ProjectContributorUpdateManyMutationInput!
    where: ProjectContributorScalarWhereInput!
}

input ProjectContributorUpdateManyWithoutContributorInput {
    connect: [ProjectContributorWhereUniqueInput!]
    connectOrCreate: [ProjectContributorCreateOrConnectWithoutContributorInput!]
    create: [ProjectContributorCreateWithoutContributorInput!]
    createMany: ProjectContributorCreateManyContributorInputEnvelope
    delete: [ProjectContributorWhereUniqueInput!]
    deleteMany: [ProjectContributorScalarWhereInput!]
    disconnect: [ProjectContributorWhereUniqueInput!]
    set: [ProjectContributorWhereUniqueInput!]
    update: [ProjectContributorUpdateWithWhereUniqueWithoutContributorInput!]
    updateMany: [ProjectContributorUpdateManyWithWhereWithoutContributorInput!]
    upsert: [ProjectContributorUpsertWithWhereUniqueWithoutContributorInput!]
}

input ProjectContributorUpdateManyWithoutProjectInput {
    connect: [ProjectContributorWhereUniqueInput!]
    connectOrCreate: [ProjectContributorCreateOrConnectWithoutProjectInput!]
    create: [ProjectContributorCreateWithoutProjectInput!]
    createMany: ProjectContributorCreateManyProjectInputEnvelope
    delete: [ProjectContributorWhereUniqueInput!]
    deleteMany: [ProjectContributorScalarWhereInput!]
    disconnect: [ProjectContributorWhereUniqueInput!]
    set: [ProjectContributorWhereUniqueInput!]
    update: [ProjectContributorUpdateWithWhereUniqueWithoutProjectInput!]
    updateMany: [ProjectContributorUpdateManyWithWhereWithoutProjectInput!]
    upsert: [ProjectContributorUpsertWithWhereUniqueWithoutProjectInput!]
}

input ProjectContributorUpdateWithWhereUniqueWithoutContributorInput {
    data: ProjectContributorUpdateWithoutContributorInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorUpdateWithWhereUniqueWithoutProjectInput {
    data: ProjectContributorUpdateWithoutProjectInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorUpdateWithoutContributorInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    project: ProjectUpdateOneRequiredWithoutContributorsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectContributorUpdateWithoutProjectInput {
    contributor: PersonUpdateOneRequiredWithoutProjectsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectContributorUpsertWithWhereUniqueWithoutContributorInput {
    create: ProjectContributorCreateWithoutContributorInput!
    update: ProjectContributorUpdateWithoutContributorInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorUpsertWithWhereUniqueWithoutProjectInput {
    create: ProjectContributorCreateWithoutProjectInput!
    update: ProjectContributorUpdateWithoutProjectInput!
    where: ProjectContributorWhereUniqueInput!
}

input ProjectContributorWhereInput {
    AND: [ProjectContributorWhereInput!]
    NOT: [ProjectContributorWhereInput!]
    OR: [ProjectContributorWhereInput!]
    contributor: PersonRelationFilter
    contributorId: StringFilter
    createdAt: DateTimeFilter
    id: StringFilter
    project: ProjectRelationFilter
    projectId: StringFilter
    updatedAt: DateTimeFilter
}

input ProjectContributorWhereUniqueInput {
    id: String
}

input ProjectCountOrderByAggregateInput {
    createdAt: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    projectUrl: SortOrder
    slug: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
}

input ProjectCreateInput {
    contributors: ProjectContributorCreateNestedManyWithoutProjectInput
    createdAt: DateTime
    featuredImage: ImageCreateNestedOneWithoutProjectsInput!
    githubUrl: String
    id: String
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime
}

input ProjectCreateManyFeaturedImageInput {
    createdAt: DateTime
    githubUrl: String
    id: String
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime
}

input ProjectCreateManyFeaturedImageInputEnvelope {
    data: [ProjectCreateManyFeaturedImageInput!]!
    skipDuplicates: Boolean
}

input ProjectCreateManyInput {
    createdAt: DateTime
    githubUrl: String
    id: String
    imageId: String!
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime
}

input ProjectCreateNestedManyWithoutFeaturedImageInput {
    connect: [ProjectWhereUniqueInput!]
    connectOrCreate: [ProjectCreateOrConnectWithoutFeaturedImageInput!]
    create: [ProjectCreateWithoutFeaturedImageInput!]
    createMany: ProjectCreateManyFeaturedImageInputEnvelope
}

input ProjectCreateNestedOneWithoutContributorsInput {
    connect: ProjectWhereUniqueInput
    connectOrCreate: ProjectCreateOrConnectWithoutContributorsInput
    create: ProjectCreateWithoutContributorsInput
}

input ProjectCreateOrConnectWithoutContributorsInput {
    create: ProjectCreateWithoutContributorsInput!
    where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutFeaturedImageInput {
    create: ProjectCreateWithoutFeaturedImageInput!
    where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutContributorsInput {
    createdAt: DateTime
    featuredImage: ImageCreateNestedOneWithoutProjectsInput!
    githubUrl: String
    id: String
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime
}

input ProjectCreateWithoutFeaturedImageInput {
    contributors: ProjectContributorCreateNestedManyWithoutProjectInput
    createdAt: DateTime
    githubUrl: String
    id: String
    name: String!
    projectUrl: String
    slug: String!
    summary: String!
    updatedAt: DateTime
}

input ProjectListRelationFilter {
    every: ProjectWhereInput
    none: ProjectWhereInput
    some: ProjectWhereInput
}

input ProjectMaxOrderByAggregateInput {
    createdAt: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    projectUrl: SortOrder
    slug: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
}

input ProjectMinOrderByAggregateInput {
    createdAt: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    projectUrl: SortOrder
    slug: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
}

input ProjectOrderByRelationAggregateInput {
    _count: SortOrder
}

input ProjectOrderByWithAggregationInput {
    _count: ProjectCountOrderByAggregateInput
    _max: ProjectMaxOrderByAggregateInput
    _min: ProjectMinOrderByAggregateInput
    createdAt: SortOrder
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    projectUrl: SortOrder
    slug: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
    contributors: ProjectContributorOrderByRelationAggregateInput
    createdAt: SortOrder
    featuredImage: ImageOrderByWithRelationInput
    githubUrl: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    projectUrl: SortOrder
    slug: SortOrder
    summary: SortOrder
    updatedAt: SortOrder
}

input ProjectRelationFilter {
    is: ProjectWhereInput
    isNot: ProjectWhereInput
}

input ProjectScalarWhereInput {
    AND: [ProjectScalarWhereInput!]
    NOT: [ProjectScalarWhereInput!]
    OR: [ProjectScalarWhereInput!]
    createdAt: DateTimeFilter
    githubUrl: StringNullableFilter
    id: StringFilter
    imageId: StringFilter
    name: StringFilter
    projectUrl: StringNullableFilter
    slug: StringFilter
    summary: StringFilter
    updatedAt: DateTimeFilter
}

input ProjectScalarWhereWithAggregatesInput {
    AND: [ProjectScalarWhereWithAggregatesInput!]
    NOT: [ProjectScalarWhereWithAggregatesInput!]
    OR: [ProjectScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    githubUrl: StringNullableWithAggregatesFilter
    id: StringWithAggregatesFilter
    imageId: StringWithAggregatesFilter
    name: StringWithAggregatesFilter
    projectUrl: StringNullableWithAggregatesFilter
    slug: StringWithAggregatesFilter
    summary: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input ProjectUpdateInput {
    contributors: ProjectContributorUpdateManyWithoutProjectInput
    createdAt: DateTimeFieldUpdateOperationsInput
    featuredImage: ImageUpdateOneRequiredWithoutProjectsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    projectUrl: NullableStringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    summary: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    projectUrl: NullableStringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    summary: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyWithWhereWithoutFeaturedImageInput {
    data: ProjectUpdateManyMutationInput!
    where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithoutFeaturedImageInput {
    connect: [ProjectWhereUniqueInput!]
    connectOrCreate: [ProjectCreateOrConnectWithoutFeaturedImageInput!]
    create: [ProjectCreateWithoutFeaturedImageInput!]
    createMany: ProjectCreateManyFeaturedImageInputEnvelope
    delete: [ProjectWhereUniqueInput!]
    deleteMany: [ProjectScalarWhereInput!]
    disconnect: [ProjectWhereUniqueInput!]
    set: [ProjectWhereUniqueInput!]
    update: [ProjectUpdateWithWhereUniqueWithoutFeaturedImageInput!]
    updateMany: [ProjectUpdateManyWithWhereWithoutFeaturedImageInput!]
    upsert: [ProjectUpsertWithWhereUniqueWithoutFeaturedImageInput!]
}

input ProjectUpdateOneRequiredWithoutContributorsInput {
    connect: ProjectWhereUniqueInput
    connectOrCreate: ProjectCreateOrConnectWithoutContributorsInput
    create: ProjectCreateWithoutContributorsInput
    update: ProjectUpdateWithoutContributorsInput
    upsert: ProjectUpsertWithoutContributorsInput
}

input ProjectUpdateWithWhereUniqueWithoutFeaturedImageInput {
    data: ProjectUpdateWithoutFeaturedImageInput!
    where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithoutContributorsInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    featuredImage: ImageUpdateOneRequiredWithoutProjectsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    projectUrl: NullableStringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    summary: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutFeaturedImageInput {
    contributors: ProjectContributorUpdateManyWithoutProjectInput
    createdAt: DateTimeFieldUpdateOperationsInput
    githubUrl: NullableStringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    projectUrl: NullableStringFieldUpdateOperationsInput
    slug: StringFieldUpdateOperationsInput
    summary: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpsertWithWhereUniqueWithoutFeaturedImageInput {
    create: ProjectCreateWithoutFeaturedImageInput!
    update: ProjectUpdateWithoutFeaturedImageInput!
    where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutContributorsInput {
    create: ProjectCreateWithoutContributorsInput!
    update: ProjectUpdateWithoutContributorsInput!
}

input ProjectWhereInput {
    AND: [ProjectWhereInput!]
    NOT: [ProjectWhereInput!]
    OR: [ProjectWhereInput!]
    contributors: ProjectContributorListRelationFilter
    createdAt: DateTimeFilter
    featuredImage: ImageRelationFilter
    githubUrl: StringNullableFilter
    id: StringFilter
    imageId: StringFilter
    name: StringFilter
    projectUrl: StringNullableFilter
    slug: StringFilter
    summary: StringFilter
    updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
    id: String
    slug: String
}

input SchoolCountOrderByAggregateInput {
    createdAt: SortOrder
    description: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    updatedAt: SortOrder
    url: SortOrder
}

input SchoolCreateInput {
    courses: CourseCreateNestedManyWithoutSchoolInput
    createdAt: DateTime
    description: String!
    id: String
    logo: ImageCreateNestedOneWithoutSchoolsInput!
    name: String!
    updatedAt: DateTime
    url: String!
}

input SchoolCreateManyInput {
    createdAt: DateTime
    description: String!
    id: String
    imageId: String!
    name: String!
    updatedAt: DateTime
    url: String!
}

input SchoolCreateManyLogoInput {
    createdAt: DateTime
    description: String!
    id: String
    name: String!
    updatedAt: DateTime
    url: String!
}

input SchoolCreateManyLogoInputEnvelope {
    data: [SchoolCreateManyLogoInput!]!
    skipDuplicates: Boolean
}

input SchoolCreateNestedManyWithoutLogoInput {
    connect: [SchoolWhereUniqueInput!]
    connectOrCreate: [SchoolCreateOrConnectWithoutLogoInput!]
    create: [SchoolCreateWithoutLogoInput!]
    createMany: SchoolCreateManyLogoInputEnvelope
}

input SchoolCreateNestedOneWithoutCoursesInput {
    connect: SchoolWhereUniqueInput
    connectOrCreate: SchoolCreateOrConnectWithoutCoursesInput
    create: SchoolCreateWithoutCoursesInput
}

input SchoolCreateOrConnectWithoutCoursesInput {
    create: SchoolCreateWithoutCoursesInput!
    where: SchoolWhereUniqueInput!
}

input SchoolCreateOrConnectWithoutLogoInput {
    create: SchoolCreateWithoutLogoInput!
    where: SchoolWhereUniqueInput!
}

input SchoolCreateWithoutCoursesInput {
    createdAt: DateTime
    description: String!
    id: String
    logo: ImageCreateNestedOneWithoutSchoolsInput!
    name: String!
    updatedAt: DateTime
    url: String!
}

input SchoolCreateWithoutLogoInput {
    courses: CourseCreateNestedManyWithoutSchoolInput
    createdAt: DateTime
    description: String!
    id: String
    name: String!
    updatedAt: DateTime
    url: String!
}

input SchoolListRelationFilter {
    every: SchoolWhereInput
    none: SchoolWhereInput
    some: SchoolWhereInput
}

input SchoolMaxOrderByAggregateInput {
    createdAt: SortOrder
    description: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    updatedAt: SortOrder
    url: SortOrder
}

input SchoolMinOrderByAggregateInput {
    createdAt: SortOrder
    description: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    updatedAt: SortOrder
    url: SortOrder
}

input SchoolOrderByRelationAggregateInput {
    _count: SortOrder
}

input SchoolOrderByWithAggregationInput {
    _count: SchoolCountOrderByAggregateInput
    _max: SchoolMaxOrderByAggregateInput
    _min: SchoolMinOrderByAggregateInput
    createdAt: SortOrder
    description: SortOrder
    id: SortOrder
    imageId: SortOrder
    name: SortOrder
    updatedAt: SortOrder
    url: SortOrder
}

input SchoolOrderByWithRelationInput {
    courses: CourseOrderByRelationAggregateInput
    createdAt: SortOrder
    description: SortOrder
    id: SortOrder
    imageId: SortOrder
    logo: ImageOrderByWithRelationInput
    name: SortOrder
    updatedAt: SortOrder
    url: SortOrder
}

input SchoolRelationFilter {
    is: SchoolWhereInput
    isNot: SchoolWhereInput
}

input SchoolScalarWhereInput {
    AND: [SchoolScalarWhereInput!]
    NOT: [SchoolScalarWhereInput!]
    OR: [SchoolScalarWhereInput!]
    createdAt: DateTimeFilter
    description: StringFilter
    id: StringFilter
    imageId: StringFilter
    name: StringFilter
    updatedAt: DateTimeFilter
    url: StringFilter
}

input SchoolScalarWhereWithAggregatesInput {
    AND: [SchoolScalarWhereWithAggregatesInput!]
    NOT: [SchoolScalarWhereWithAggregatesInput!]
    OR: [SchoolScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    description: StringWithAggregatesFilter
    id: StringWithAggregatesFilter
    imageId: StringWithAggregatesFilter
    name: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    url: StringWithAggregatesFilter
}

input SchoolUpdateInput {
    courses: CourseUpdateManyWithoutSchoolInput
    createdAt: DateTimeFieldUpdateOperationsInput
    description: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    logo: ImageUpdateOneRequiredWithoutSchoolsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
}

input SchoolUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    description: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
}

input SchoolUpdateManyWithWhereWithoutLogoInput {
    data: SchoolUpdateManyMutationInput!
    where: SchoolScalarWhereInput!
}

input SchoolUpdateManyWithoutLogoInput {
    connect: [SchoolWhereUniqueInput!]
    connectOrCreate: [SchoolCreateOrConnectWithoutLogoInput!]
    create: [SchoolCreateWithoutLogoInput!]
    createMany: SchoolCreateManyLogoInputEnvelope
    delete: [SchoolWhereUniqueInput!]
    deleteMany: [SchoolScalarWhereInput!]
    disconnect: [SchoolWhereUniqueInput!]
    set: [SchoolWhereUniqueInput!]
    update: [SchoolUpdateWithWhereUniqueWithoutLogoInput!]
    updateMany: [SchoolUpdateManyWithWhereWithoutLogoInput!]
    upsert: [SchoolUpsertWithWhereUniqueWithoutLogoInput!]
}

input SchoolUpdateOneRequiredWithoutCoursesInput {
    connect: SchoolWhereUniqueInput
    connectOrCreate: SchoolCreateOrConnectWithoutCoursesInput
    create: SchoolCreateWithoutCoursesInput
    update: SchoolUpdateWithoutCoursesInput
    upsert: SchoolUpsertWithoutCoursesInput
}

input SchoolUpdateWithWhereUniqueWithoutLogoInput {
    data: SchoolUpdateWithoutLogoInput!
    where: SchoolWhereUniqueInput!
}

input SchoolUpdateWithoutCoursesInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    description: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    logo: ImageUpdateOneRequiredWithoutSchoolsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
}

input SchoolUpdateWithoutLogoInput {
    courses: CourseUpdateManyWithoutSchoolInput
    createdAt: DateTimeFieldUpdateOperationsInput
    description: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    url: StringFieldUpdateOperationsInput
}

input SchoolUpsertWithWhereUniqueWithoutLogoInput {
    create: SchoolCreateWithoutLogoInput!
    update: SchoolUpdateWithoutLogoInput!
    where: SchoolWhereUniqueInput!
}

input SchoolUpsertWithoutCoursesInput {
    create: SchoolCreateWithoutCoursesInput!
    update: SchoolUpdateWithoutCoursesInput!
}

input SchoolWhereInput {
    AND: [SchoolWhereInput!]
    NOT: [SchoolWhereInput!]
    OR: [SchoolWhereInput!]
    courses: CourseListRelationFilter
    createdAt: DateTimeFilter
    description: StringFilter
    id: StringFilter
    imageId: StringFilter
    logo: ImageRelationFilter
    name: StringFilter
    updatedAt: DateTimeFilter
    url: StringFilter
}

input SchoolWhereUniqueInput {
    id: String
    url: String
}

input StringFieldUpdateOperationsInput {
    set: String
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableListFilter {
    equals: [String!]
    has: String
    hasEvery: [String!]
    hasSome: [String!]
    isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input StringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input TechnologyLogoCountOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    isOnHomepage: SortOrder
    name: SortOrder
    updatedAt: SortOrder
}

input TechnologyLogoCreateInput {
    createdAt: DateTime
    id: String
    isOnHomepage: Boolean!
    logo: ImageCreateNestedOneWithoutTechnologyLogosInput!
    name: String!
    updatedAt: DateTime
}

input TechnologyLogoCreateManyInput {
    createdAt: DateTime
    id: String
    imageId: String!
    isOnHomepage: Boolean!
    name: String!
    updatedAt: DateTime
}

input TechnologyLogoCreateManyLogoInput {
    createdAt: DateTime
    id: String
    isOnHomepage: Boolean!
    name: String!
    updatedAt: DateTime
}

input TechnologyLogoCreateManyLogoInputEnvelope {
    data: [TechnologyLogoCreateManyLogoInput!]!
    skipDuplicates: Boolean
}

input TechnologyLogoCreateNestedManyWithoutLogoInput {
    connect: [TechnologyLogoWhereUniqueInput!]
    connectOrCreate: [TechnologyLogoCreateOrConnectWithoutLogoInput!]
    create: [TechnologyLogoCreateWithoutLogoInput!]
    createMany: TechnologyLogoCreateManyLogoInputEnvelope
}

input TechnologyLogoCreateOrConnectWithoutLogoInput {
    create: TechnologyLogoCreateWithoutLogoInput!
    where: TechnologyLogoWhereUniqueInput!
}

input TechnologyLogoCreateWithoutLogoInput {
    createdAt: DateTime
    id: String
    isOnHomepage: Boolean!
    name: String!
    updatedAt: DateTime
}

input TechnologyLogoListRelationFilter {
    every: TechnologyLogoWhereInput
    none: TechnologyLogoWhereInput
    some: TechnologyLogoWhereInput
}

input TechnologyLogoMaxOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    isOnHomepage: SortOrder
    name: SortOrder
    updatedAt: SortOrder
}

input TechnologyLogoMinOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    isOnHomepage: SortOrder
    name: SortOrder
    updatedAt: SortOrder
}

input TechnologyLogoOrderByRelationAggregateInput {
    _count: SortOrder
}

input TechnologyLogoOrderByWithAggregationInput {
    _count: TechnologyLogoCountOrderByAggregateInput
    _max: TechnologyLogoMaxOrderByAggregateInput
    _min: TechnologyLogoMinOrderByAggregateInput
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    isOnHomepage: SortOrder
    name: SortOrder
    updatedAt: SortOrder
}

input TechnologyLogoOrderByWithRelationInput {
    createdAt: SortOrder
    id: SortOrder
    imageId: SortOrder
    isOnHomepage: SortOrder
    logo: ImageOrderByWithRelationInput
    name: SortOrder
    updatedAt: SortOrder
}

input TechnologyLogoScalarWhereInput {
    AND: [TechnologyLogoScalarWhereInput!]
    NOT: [TechnologyLogoScalarWhereInput!]
    OR: [TechnologyLogoScalarWhereInput!]
    createdAt: DateTimeFilter
    id: StringFilter
    imageId: StringFilter
    isOnHomepage: BoolFilter
    name: StringFilter
    updatedAt: DateTimeFilter
}

input TechnologyLogoScalarWhereWithAggregatesInput {
    AND: [TechnologyLogoScalarWhereWithAggregatesInput!]
    NOT: [TechnologyLogoScalarWhereWithAggregatesInput!]
    OR: [TechnologyLogoScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    imageId: StringWithAggregatesFilter
    isOnHomepage: BoolWithAggregatesFilter
    name: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input TechnologyLogoUpdateInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    isOnHomepage: BoolFieldUpdateOperationsInput
    logo: ImageUpdateOneRequiredWithoutTechnologyLogosInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input TechnologyLogoUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    isOnHomepage: BoolFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input TechnologyLogoUpdateManyWithWhereWithoutLogoInput {
    data: TechnologyLogoUpdateManyMutationInput!
    where: TechnologyLogoScalarWhereInput!
}

input TechnologyLogoUpdateManyWithoutLogoInput {
    connect: [TechnologyLogoWhereUniqueInput!]
    connectOrCreate: [TechnologyLogoCreateOrConnectWithoutLogoInput!]
    create: [TechnologyLogoCreateWithoutLogoInput!]
    createMany: TechnologyLogoCreateManyLogoInputEnvelope
    delete: [TechnologyLogoWhereUniqueInput!]
    deleteMany: [TechnologyLogoScalarWhereInput!]
    disconnect: [TechnologyLogoWhereUniqueInput!]
    set: [TechnologyLogoWhereUniqueInput!]
    update: [TechnologyLogoUpdateWithWhereUniqueWithoutLogoInput!]
    updateMany: [TechnologyLogoUpdateManyWithWhereWithoutLogoInput!]
    upsert: [TechnologyLogoUpsertWithWhereUniqueWithoutLogoInput!]
}

input TechnologyLogoUpdateWithWhereUniqueWithoutLogoInput {
    data: TechnologyLogoUpdateWithoutLogoInput!
    where: TechnologyLogoWhereUniqueInput!
}

input TechnologyLogoUpdateWithoutLogoInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    isOnHomepage: BoolFieldUpdateOperationsInput
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input TechnologyLogoUpsertWithWhereUniqueWithoutLogoInput {
    create: TechnologyLogoCreateWithoutLogoInput!
    update: TechnologyLogoUpdateWithoutLogoInput!
    where: TechnologyLogoWhereUniqueInput!
}

input TechnologyLogoWhereInput {
    AND: [TechnologyLogoWhereInput!]
    NOT: [TechnologyLogoWhereInput!]
    OR: [TechnologyLogoWhereInput!]
    createdAt: DateTimeFilter
    id: StringFilter
    imageId: StringFilter
    isOnHomepage: BoolFilter
    logo: ImageRelationFilter
    name: StringFilter
    updatedAt: DateTimeFilter
}

input TechnologyLogoWhereUniqueInput {
    id: String
    imageId: String
}

input UserCountOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    password: SortOrder
    personId: SortOrder
    role: SortOrder
    updatedAt: SortOrder
    username: SortOrder
}

input UserCreateInput {
    createdAt: DateTime
    id: String
    password: String!
    person: PersonCreateNestedOneWithoutUserInput!
    role: Role
    updatedAt: DateTime
    username: String!
}

input UserCreateManyInput {
    createdAt: DateTime
    id: String
    password: String!
    personId: String!
    role: Role
    updatedAt: DateTime
    username: String!
}

input UserCreateManyPersonInput {
    createdAt: DateTime
    id: String
    password: String!
    role: Role
    updatedAt: DateTime
    username: String!
}

input UserCreateManyPersonInputEnvelope {
    data: [UserCreateManyPersonInput!]!
    skipDuplicates: Boolean
}

input UserCreateNestedManyWithoutPersonInput {
    connect: [UserWhereUniqueInput!]
    connectOrCreate: [UserCreateOrConnectWithoutPersonInput!]
    create: [UserCreateWithoutPersonInput!]
    createMany: UserCreateManyPersonInputEnvelope
}

input UserCreateOrConnectWithoutPersonInput {
    create: UserCreateWithoutPersonInput!
    where: UserWhereUniqueInput!
}

input UserCreateWithoutPersonInput {
    createdAt: DateTime
    id: String
    password: String!
    role: Role
    updatedAt: DateTime
    username: String!
}

input UserListRelationFilter {
    every: UserWhereInput
    none: UserWhereInput
    some: UserWhereInput
}

input UserMaxOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    password: SortOrder
    personId: SortOrder
    role: SortOrder
    updatedAt: SortOrder
    username: SortOrder
}

input UserMinOrderByAggregateInput {
    createdAt: SortOrder
    id: SortOrder
    password: SortOrder
    personId: SortOrder
    role: SortOrder
    updatedAt: SortOrder
    username: SortOrder
}

input UserOrderByRelationAggregateInput {
    _count: SortOrder
}

input UserOrderByWithAggregationInput {
    _count: UserCountOrderByAggregateInput
    _max: UserMaxOrderByAggregateInput
    _min: UserMinOrderByAggregateInput
    createdAt: SortOrder
    id: SortOrder
    password: SortOrder
    personId: SortOrder
    role: SortOrder
    updatedAt: SortOrder
    username: SortOrder
}

input UserOrderByWithRelationInput {
    createdAt: SortOrder
    id: SortOrder
    password: SortOrder
    person: PersonOrderByWithRelationInput
    personId: SortOrder
    role: SortOrder
    updatedAt: SortOrder
    username: SortOrder
}

input UserScalarWhereInput {
    AND: [UserScalarWhereInput!]
    NOT: [UserScalarWhereInput!]
    OR: [UserScalarWhereInput!]
    createdAt: DateTimeFilter
    id: StringFilter
    password: StringFilter
    personId: StringFilter
    role: EnumRoleFilter
    updatedAt: DateTimeFilter
    username: StringFilter
}

input UserScalarWhereWithAggregatesInput {
    AND: [UserScalarWhereWithAggregatesInput!]
    NOT: [UserScalarWhereWithAggregatesInput!]
    OR: [UserScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    password: StringWithAggregatesFilter
    personId: StringWithAggregatesFilter
    role: EnumRoleWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    username: StringWithAggregatesFilter
}

input UserUpdateInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    password: StringFieldUpdateOperationsInput
    person: PersonUpdateOneRequiredWithoutUserInput
    role: EnumRoleFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    password: StringFieldUpdateOperationsInput
    role: EnumRoleFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    username: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutPersonInput {
    data: UserUpdateManyMutationInput!
    where: UserScalarWhereInput!
}

input UserUpdateManyWithoutPersonInput {
    connect: [UserWhereUniqueInput!]
    connectOrCreate: [UserCreateOrConnectWithoutPersonInput!]
    create: [UserCreateWithoutPersonInput!]
    createMany: UserCreateManyPersonInputEnvelope
    delete: [UserWhereUniqueInput!]
    deleteMany: [UserScalarWhereInput!]
    disconnect: [UserWhereUniqueInput!]
    set: [UserWhereUniqueInput!]
    update: [UserUpdateWithWhereUniqueWithoutPersonInput!]
    updateMany: [UserUpdateManyWithWhereWithoutPersonInput!]
    upsert: [UserUpsertWithWhereUniqueWithoutPersonInput!]
}

input UserUpdateWithWhereUniqueWithoutPersonInput {
    data: UserUpdateWithoutPersonInput!
    where: UserWhereUniqueInput!
}

input UserUpdateWithoutPersonInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    password: StringFieldUpdateOperationsInput
    role: EnumRoleFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    username: StringFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutPersonInput {
    create: UserCreateWithoutPersonInput!
    update: UserUpdateWithoutPersonInput!
    where: UserWhereUniqueInput!
}

input UserUsernamePasswordCompoundUniqueInput {
    password: String!
    username: String!
}

input UserWhereInput {
    AND: [UserWhereInput!]
    NOT: [UserWhereInput!]
    OR: [UserWhereInput!]
    createdAt: DateTimeFilter
    id: StringFilter
    password: StringFilter
    person: PersonRelationFilter
    personId: StringFilter
    role: EnumRoleFilter
    updatedAt: DateTimeFilter
    username: StringFilter
}

input UserWhereUniqueInput {
    id: String
    username: String
    username_password: UserUsernamePasswordCompoundUniqueInput
}
