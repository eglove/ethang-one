# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
  "refresh the cache entry"
  refresh: Boolean! = false,
  "measured in seconds"
  ttl: Int! = 60
) on QUERY

"columns and relationships of \"Blog\""
type Blog {
  "An array relationship"
  BlogAuthors(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): [BlogAuthor!]!
  "An aggregate relationship"
  BlogAuthors_aggregate(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): BlogAuthor_aggregate!
  "An object relationship"
  Image: Image!
  content: String!
  createdAt: timestamp!
  id: uuid!
  imageId: uuid!
  slug: String!
  title: String!
  updatedAt: timestamp!
}

"columns and relationships of \"BlogAuthor\""
type BlogAuthor {
  "An object relationship"
  Blog: Blog!
  "An object relationship"
  Person: Person!
  blogId: uuid!
  createdAt: timestamp!
  id: uuid!
  personId: uuid!
  updatedAt: timestamp!
}

"aggregated selection of \"BlogAuthor\""
type BlogAuthor_aggregate {
  aggregate: BlogAuthor_aggregate_fields
  nodes: [BlogAuthor!]!
}

"aggregate fields of \"BlogAuthor\""
type BlogAuthor_aggregate_fields {
  count(columns: [BlogAuthor_select_column!], distinct: Boolean): Int!
  max: BlogAuthor_max_fields
  min: BlogAuthor_min_fields
}

"aggregate max on columns"
type BlogAuthor_max_fields {
  blogId: uuid
  createdAt: timestamp
  id: uuid
  personId: uuid
  updatedAt: timestamp
}

"aggregate min on columns"
type BlogAuthor_min_fields {
  blogId: uuid
  createdAt: timestamp
  id: uuid
  personId: uuid
  updatedAt: timestamp
}

"response of any mutation on the table \"BlogAuthor\""
type BlogAuthor_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [BlogAuthor!]!
}

"aggregated selection of \"Blog\""
type Blog_aggregate {
  aggregate: Blog_aggregate_fields
  nodes: [Blog!]!
}

"aggregate fields of \"Blog\""
type Blog_aggregate_fields {
  count(columns: [Blog_select_column!], distinct: Boolean): Int!
  max: Blog_max_fields
  min: Blog_min_fields
}

"aggregate max on columns"
type Blog_max_fields {
  content: String
  createdAt: timestamp
  id: uuid
  imageId: uuid
  slug: String
  title: String
  updatedAt: timestamp
}

"aggregate min on columns"
type Blog_min_fields {
  content: String
  createdAt: timestamp
  id: uuid
  imageId: uuid
  slug: String
  title: String
  updatedAt: timestamp
}

"response of any mutation on the table \"Blog\""
type Blog_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Blog!]!
}

"columns and relationships of \"Course\""
type Course {
  "An array relationship"
  CourseInstructors(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): [CourseInstructor!]!
  "An aggregate relationship"
  CourseInstructors_aggregate(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): CourseInstructor_aggregate!
  "An array relationship"
  CourseUrls(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): [CourseUrl!]!
  "An aggregate relationship"
  CourseUrls_aggregate(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): CourseUrl_aggregate!
  "An object relationship"
  School: School!
  complete: Boolean!
  createdAt: timestamp!
  duration: float8!
  id: uuid!
  order: Int!
  rating: Rating
  ratingUrl: String
  recommended: Boolean!
  schoolId: uuid!
  title: String!
  updatedAt: timestamp!
  yearUpdated: Int!
}

"columns and relationships of \"CourseInstructor\""
type CourseInstructor {
  "An object relationship"
  Course: Course!
  "An object relationship"
  Person: Person!
  courseId: uuid!
  createdAt: timestamp!
  id: uuid!
  instructorId: uuid!
  updatedAt: timestamp!
}

"aggregated selection of \"CourseInstructor\""
type CourseInstructor_aggregate {
  aggregate: CourseInstructor_aggregate_fields
  nodes: [CourseInstructor!]!
}

"aggregate fields of \"CourseInstructor\""
type CourseInstructor_aggregate_fields {
  count(columns: [CourseInstructor_select_column!], distinct: Boolean): Int!
  max: CourseInstructor_max_fields
  min: CourseInstructor_min_fields
}

"aggregate max on columns"
type CourseInstructor_max_fields {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  instructorId: uuid
  updatedAt: timestamp
}

"aggregate min on columns"
type CourseInstructor_min_fields {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  instructorId: uuid
  updatedAt: timestamp
}

"response of any mutation on the table \"CourseInstructor\""
type CourseInstructor_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CourseInstructor!]!
}

"columns and relationships of \"CourseUrl\""
type CourseUrl {
  "An object relationship"
  Course: Course!
  "An object relationship"
  School: School!
  courseId: uuid!
  createdAt: timestamp!
  id: uuid!
  schoolId: uuid!
  updatedAt: timestamp!
  url: String!
}

"aggregated selection of \"CourseUrl\""
type CourseUrl_aggregate {
  aggregate: CourseUrl_aggregate_fields
  nodes: [CourseUrl!]!
}

"aggregate fields of \"CourseUrl\""
type CourseUrl_aggregate_fields {
  count(columns: [CourseUrl_select_column!], distinct: Boolean): Int!
  max: CourseUrl_max_fields
  min: CourseUrl_min_fields
}

"aggregate max on columns"
type CourseUrl_max_fields {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  schoolId: uuid
  updatedAt: timestamp
  url: String
}

"aggregate min on columns"
type CourseUrl_min_fields {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  schoolId: uuid
  updatedAt: timestamp
  url: String
}

"response of any mutation on the table \"CourseUrl\""
type CourseUrl_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [CourseUrl!]!
}

"aggregated selection of \"Course\""
type Course_aggregate {
  aggregate: Course_aggregate_fields
  nodes: [Course!]!
}

"aggregate fields of \"Course\""
type Course_aggregate_fields {
  avg: Course_avg_fields
  count(columns: [Course_select_column!], distinct: Boolean): Int!
  max: Course_max_fields
  min: Course_min_fields
  stddev: Course_stddev_fields
  stddev_pop: Course_stddev_pop_fields
  stddev_samp: Course_stddev_samp_fields
  sum: Course_sum_fields
  var_pop: Course_var_pop_fields
  var_samp: Course_var_samp_fields
  variance: Course_variance_fields
}

"aggregate avg on columns"
type Course_avg_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate max on columns"
type Course_max_fields {
  createdAt: timestamp
  duration: float8
  id: uuid
  order: Int
  ratingUrl: String
  schoolId: uuid
  title: String
  updatedAt: timestamp
  yearUpdated: Int
}

"aggregate min on columns"
type Course_min_fields {
  createdAt: timestamp
  duration: float8
  id: uuid
  order: Int
  ratingUrl: String
  schoolId: uuid
  title: String
  updatedAt: timestamp
  yearUpdated: Int
}

"response of any mutation on the table \"Course\""
type Course_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Course!]!
}

"aggregate stddev on columns"
type Course_stddev_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate stddev_pop on columns"
type Course_stddev_pop_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate stddev_samp on columns"
type Course_stddev_samp_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate sum on columns"
type Course_sum_fields {
  duration: float8
  order: Int
  yearUpdated: Int
}

"aggregate var_pop on columns"
type Course_var_pop_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate var_samp on columns"
type Course_var_samp_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"aggregate variance on columns"
type Course_variance_fields {
  duration: Float
  order: Float
  yearUpdated: Float
}

"columns and relationships of \"Image\""
type Image {
  "An array relationship"
  Blogs(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): [Blog!]!
  "An aggregate relationship"
  Blogs_aggregate(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): Blog_aggregate!
  "An array relationship"
  People(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): [Person!]!
  "An aggregate relationship"
  People_aggregate(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): Person_aggregate!
  "An array relationship"
  Projects(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): [Project!]!
  "An aggregate relationship"
  Projects_aggregate(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): Project_aggregate!
  "An array relationship"
  Schools(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): [School!]!
  "An aggregate relationship"
  Schools_aggregate(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): School_aggregate!
  "An array relationship"
  TechnologyLogos(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): [TechnologyLogo!]!
  "An aggregate relationship"
  TechnologyLogos_aggregate(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): TechnologyLogo_aggregate!
  altText: String!
  createdAt: timestamp!
  height: String!
  id: uuid!
  updatedAt: timestamp!
  url: String!
  width: String!
}

"aggregated selection of \"Image\""
type Image_aggregate {
  aggregate: Image_aggregate_fields
  nodes: [Image!]!
}

"aggregate fields of \"Image\""
type Image_aggregate_fields {
  count(columns: [Image_select_column!], distinct: Boolean): Int!
  max: Image_max_fields
  min: Image_min_fields
}

"aggregate max on columns"
type Image_max_fields {
  altText: String
  createdAt: timestamp
  height: String
  id: uuid
  updatedAt: timestamp
  url: String
  width: String
}

"aggregate min on columns"
type Image_min_fields {
  altText: String
  createdAt: timestamp
  height: String
  id: uuid
  updatedAt: timestamp
  url: String
  width: String
}

"response of any mutation on the table \"Image\""
type Image_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Image!]!
}

"columns and relationships of \"Person\""
type Person {
  "An array relationship"
  BlogAuthors(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): [BlogAuthor!]!
  "An aggregate relationship"
  BlogAuthors_aggregate(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): BlogAuthor_aggregate!
  "An array relationship"
  CourseInstructors(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): [CourseInstructor!]!
  "An aggregate relationship"
  CourseInstructors_aggregate(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): CourseInstructor_aggregate!
  "An object relationship"
  Image: Image
  "An array relationship"
  ProjectContributors(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): [ProjectContributor!]!
  "An aggregate relationship"
  ProjectContributors_aggregate(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): ProjectContributor_aggregate!
  "An array relationship"
  Users(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): [User!]!
  "An aggregate relationship"
  Users_aggregate(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): User_aggregate!
  createdAt: timestamp!
  firstName: String!
  githubUrl: String
  id: uuid!
  imageId: uuid
  lastName: String!
  linkedinUrl: String
  summary: String
  updatedAt: timestamp!
  websiteUrl: String
}

"aggregated selection of \"Person\""
type Person_aggregate {
  aggregate: Person_aggregate_fields
  nodes: [Person!]!
}

"aggregate fields of \"Person\""
type Person_aggregate_fields {
  count(columns: [Person_select_column!], distinct: Boolean): Int!
  max: Person_max_fields
  min: Person_min_fields
}

"aggregate max on columns"
type Person_max_fields {
  createdAt: timestamp
  firstName: String
  githubUrl: String
  id: uuid
  imageId: uuid
  lastName: String
  linkedinUrl: String
  summary: String
  updatedAt: timestamp
  websiteUrl: String
}

"aggregate min on columns"
type Person_min_fields {
  createdAt: timestamp
  firstName: String
  githubUrl: String
  id: uuid
  imageId: uuid
  lastName: String
  linkedinUrl: String
  summary: String
  updatedAt: timestamp
  websiteUrl: String
}

"response of any mutation on the table \"Person\""
type Person_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Person!]!
}

"columns and relationships of \"Project\""
type Project {
  "An object relationship"
  Image: Image!
  "An array relationship"
  ProjectContributors(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): [ProjectContributor!]!
  "An aggregate relationship"
  ProjectContributors_aggregate(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): ProjectContributor_aggregate!
  createdAt: timestamp!
  githubUrl: String
  id: uuid!
  imageId: uuid!
  name: String!
  projectUrl: String
  slug: String!
  summary: String!
  updatedAt: timestamp!
}

"columns and relationships of \"ProjectContributor\""
type ProjectContributor {
  "An object relationship"
  Person: Person!
  "An object relationship"
  Project: Project!
  contributorId: uuid!
  createdAt: timestamp!
  id: uuid!
  projectId: uuid!
  updatedAt: timestamp!
}

"aggregated selection of \"ProjectContributor\""
type ProjectContributor_aggregate {
  aggregate: ProjectContributor_aggregate_fields
  nodes: [ProjectContributor!]!
}

"aggregate fields of \"ProjectContributor\""
type ProjectContributor_aggregate_fields {
  count(columns: [ProjectContributor_select_column!], distinct: Boolean): Int!
  max: ProjectContributor_max_fields
  min: ProjectContributor_min_fields
}

"aggregate max on columns"
type ProjectContributor_max_fields {
  contributorId: uuid
  createdAt: timestamp
  id: uuid
  projectId: uuid
  updatedAt: timestamp
}

"aggregate min on columns"
type ProjectContributor_min_fields {
  contributorId: uuid
  createdAt: timestamp
  id: uuid
  projectId: uuid
  updatedAt: timestamp
}

"response of any mutation on the table \"ProjectContributor\""
type ProjectContributor_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [ProjectContributor!]!
}

"aggregated selection of \"Project\""
type Project_aggregate {
  aggregate: Project_aggregate_fields
  nodes: [Project!]!
}

"aggregate fields of \"Project\""
type Project_aggregate_fields {
  count(columns: [Project_select_column!], distinct: Boolean): Int!
  max: Project_max_fields
  min: Project_min_fields
}

"aggregate max on columns"
type Project_max_fields {
  createdAt: timestamp
  githubUrl: String
  id: uuid
  imageId: uuid
  name: String
  projectUrl: String
  slug: String
  summary: String
  updatedAt: timestamp
}

"aggregate min on columns"
type Project_min_fields {
  createdAt: timestamp
  githubUrl: String
  id: uuid
  imageId: uuid
  name: String
  projectUrl: String
  slug: String
  summary: String
  updatedAt: timestamp
}

"response of any mutation on the table \"Project\""
type Project_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [Project!]!
}

"columns and relationships of \"School\""
type School {
  "An array relationship"
  CourseUrls(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): [CourseUrl!]!
  "An aggregate relationship"
  CourseUrls_aggregate(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): CourseUrl_aggregate!
  "An array relationship"
  Courses(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): [Course!]!
  "An aggregate relationship"
  Courses_aggregate(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): Course_aggregate!
  "An object relationship"
  Image: Image!
  createdAt: timestamp!
  description: String!
  id: uuid!
  imageId: uuid!
  name: String!
  updatedAt: timestamp!
  url: String!
}

"aggregated selection of \"School\""
type School_aggregate {
  aggregate: School_aggregate_fields
  nodes: [School!]!
}

"aggregate fields of \"School\""
type School_aggregate_fields {
  count(columns: [School_select_column!], distinct: Boolean): Int!
  max: School_max_fields
  min: School_min_fields
}

"aggregate max on columns"
type School_max_fields {
  createdAt: timestamp
  description: String
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
  url: String
}

"aggregate min on columns"
type School_min_fields {
  createdAt: timestamp
  description: String
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
  url: String
}

"response of any mutation on the table \"School\""
type School_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [School!]!
}

"columns and relationships of \"TechnologyLogo\""
type TechnologyLogo {
  "An object relationship"
  Image: Image!
  createdAt: timestamp!
  id: uuid!
  imageId: uuid!
  isOnHomepage: Boolean!
  name: String!
  updatedAt: timestamp!
}

"aggregated selection of \"TechnologyLogo\""
type TechnologyLogo_aggregate {
  aggregate: TechnologyLogo_aggregate_fields
  nodes: [TechnologyLogo!]!
}

"aggregate fields of \"TechnologyLogo\""
type TechnologyLogo_aggregate_fields {
  count(columns: [TechnologyLogo_select_column!], distinct: Boolean): Int!
  max: TechnologyLogo_max_fields
  min: TechnologyLogo_min_fields
}

"aggregate max on columns"
type TechnologyLogo_max_fields {
  createdAt: timestamp
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
}

"aggregate min on columns"
type TechnologyLogo_min_fields {
  createdAt: timestamp
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
}

"response of any mutation on the table \"TechnologyLogo\""
type TechnologyLogo_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [TechnologyLogo!]!
}

"columns and relationships of \"User\""
type User {
  "An object relationship"
  Person: Person!
  createdAt: timestamp!
  id: uuid!
  password: String!
  personId: uuid!
  role: Role!
  updatedAt: timestamp!
  username: String!
}

"aggregated selection of \"User\""
type User_aggregate {
  aggregate: User_aggregate_fields
  nodes: [User!]!
}

"aggregate fields of \"User\""
type User_aggregate_fields {
  count(columns: [User_select_column!], distinct: Boolean): Int!
  max: User_max_fields
  min: User_min_fields
}

"aggregate max on columns"
type User_max_fields {
  createdAt: timestamp
  id: uuid
  password: String
  personId: uuid
  updatedAt: timestamp
  username: String
}

"aggregate min on columns"
type User_min_fields {
  createdAt: timestamp
  id: uuid
  password: String
  personId: uuid
  updatedAt: timestamp
  username: String
}

"response of any mutation on the table \"User\""
type User_mutation_response {
  "number of rows affected by the mutation"
  affected_rows: Int!
  "data from the rows affected by the mutation"
  returning: [User!]!
}

"mutation root"
type mutation_root {
  "delete data from the table: \"Blog\""
  delete_Blog(
    "filter the rows which have to be deleted"
    where: Blog_bool_exp!
  ): Blog_mutation_response
  "delete data from the table: \"BlogAuthor\""
  delete_BlogAuthor(
    "filter the rows which have to be deleted"
    where: BlogAuthor_bool_exp!
  ): BlogAuthor_mutation_response
  "delete single row from the table: \"BlogAuthor\""
  delete_BlogAuthor_by_pk(id: uuid!): BlogAuthor
  "delete single row from the table: \"Blog\""
  delete_Blog_by_pk(id: uuid!): Blog
  "delete data from the table: \"Course\""
  delete_Course(
    "filter the rows which have to be deleted"
    where: Course_bool_exp!
  ): Course_mutation_response
  "delete data from the table: \"CourseInstructor\""
  delete_CourseInstructor(
    "filter the rows which have to be deleted"
    where: CourseInstructor_bool_exp!
  ): CourseInstructor_mutation_response
  "delete single row from the table: \"CourseInstructor\""
  delete_CourseInstructor_by_pk(id: uuid!): CourseInstructor
  "delete data from the table: \"CourseUrl\""
  delete_CourseUrl(
    "filter the rows which have to be deleted"
    where: CourseUrl_bool_exp!
  ): CourseUrl_mutation_response
  "delete single row from the table: \"CourseUrl\""
  delete_CourseUrl_by_pk(id: uuid!): CourseUrl
  "delete single row from the table: \"Course\""
  delete_Course_by_pk(id: uuid!): Course
  "delete data from the table: \"Image\""
  delete_Image(
    "filter the rows which have to be deleted"
    where: Image_bool_exp!
  ): Image_mutation_response
  "delete single row from the table: \"Image\""
  delete_Image_by_pk(id: uuid!): Image
  "delete data from the table: \"Person\""
  delete_Person(
    "filter the rows which have to be deleted"
    where: Person_bool_exp!
  ): Person_mutation_response
  "delete single row from the table: \"Person\""
  delete_Person_by_pk(id: uuid!): Person
  "delete data from the table: \"Project\""
  delete_Project(
    "filter the rows which have to be deleted"
    where: Project_bool_exp!
  ): Project_mutation_response
  "delete data from the table: \"ProjectContributor\""
  delete_ProjectContributor(
    "filter the rows which have to be deleted"
    where: ProjectContributor_bool_exp!
  ): ProjectContributor_mutation_response
  "delete single row from the table: \"ProjectContributor\""
  delete_ProjectContributor_by_pk(id: uuid!): ProjectContributor
  "delete single row from the table: \"Project\""
  delete_Project_by_pk(id: uuid!): Project
  "delete data from the table: \"School\""
  delete_School(
    "filter the rows which have to be deleted"
    where: School_bool_exp!
  ): School_mutation_response
  "delete single row from the table: \"School\""
  delete_School_by_pk(id: uuid!): School
  "delete data from the table: \"TechnologyLogo\""
  delete_TechnologyLogo(
    "filter the rows which have to be deleted"
    where: TechnologyLogo_bool_exp!
  ): TechnologyLogo_mutation_response
  "delete single row from the table: \"TechnologyLogo\""
  delete_TechnologyLogo_by_pk(id: uuid!): TechnologyLogo
  "delete data from the table: \"User\""
  delete_User(
    "filter the rows which have to be deleted"
    where: User_bool_exp!
  ): User_mutation_response
  "delete single row from the table: \"User\""
  delete_User_by_pk(id: uuid!): User
  "insert data into the table: \"Blog\""
  insert_Blog(
    "the rows to be inserted"
    objects: [Blog_insert_input!]!,
    "on conflict condition"
    on_conflict: Blog_on_conflict
  ): Blog_mutation_response
  "insert data into the table: \"BlogAuthor\""
  insert_BlogAuthor(
    "the rows to be inserted"
    objects: [BlogAuthor_insert_input!]!,
    "on conflict condition"
    on_conflict: BlogAuthor_on_conflict
  ): BlogAuthor_mutation_response
  "insert a single row into the table: \"BlogAuthor\""
  insert_BlogAuthor_one(
    "the row to be inserted"
    object: BlogAuthor_insert_input!,
    "on conflict condition"
    on_conflict: BlogAuthor_on_conflict
  ): BlogAuthor
  "insert a single row into the table: \"Blog\""
  insert_Blog_one(
    "the row to be inserted"
    object: Blog_insert_input!,
    "on conflict condition"
    on_conflict: Blog_on_conflict
  ): Blog
  "insert data into the table: \"Course\""
  insert_Course(
    "the rows to be inserted"
    objects: [Course_insert_input!]!,
    "on conflict condition"
    on_conflict: Course_on_conflict
  ): Course_mutation_response
  "insert data into the table: \"CourseInstructor\""
  insert_CourseInstructor(
    "the rows to be inserted"
    objects: [CourseInstructor_insert_input!]!,
    "on conflict condition"
    on_conflict: CourseInstructor_on_conflict
  ): CourseInstructor_mutation_response
  "insert a single row into the table: \"CourseInstructor\""
  insert_CourseInstructor_one(
    "the row to be inserted"
    object: CourseInstructor_insert_input!,
    "on conflict condition"
    on_conflict: CourseInstructor_on_conflict
  ): CourseInstructor
  "insert data into the table: \"CourseUrl\""
  insert_CourseUrl(
    "the rows to be inserted"
    objects: [CourseUrl_insert_input!]!,
    "on conflict condition"
    on_conflict: CourseUrl_on_conflict
  ): CourseUrl_mutation_response
  "insert a single row into the table: \"CourseUrl\""
  insert_CourseUrl_one(
    "the row to be inserted"
    object: CourseUrl_insert_input!,
    "on conflict condition"
    on_conflict: CourseUrl_on_conflict
  ): CourseUrl
  "insert a single row into the table: \"Course\""
  insert_Course_one(
    "the row to be inserted"
    object: Course_insert_input!,
    "on conflict condition"
    on_conflict: Course_on_conflict
  ): Course
  "insert data into the table: \"Image\""
  insert_Image(
    "the rows to be inserted"
    objects: [Image_insert_input!]!,
    "on conflict condition"
    on_conflict: Image_on_conflict
  ): Image_mutation_response
  "insert a single row into the table: \"Image\""
  insert_Image_one(
    "the row to be inserted"
    object: Image_insert_input!,
    "on conflict condition"
    on_conflict: Image_on_conflict
  ): Image
  "insert data into the table: \"Person\""
  insert_Person(
    "the rows to be inserted"
    objects: [Person_insert_input!]!,
    "on conflict condition"
    on_conflict: Person_on_conflict
  ): Person_mutation_response
  "insert a single row into the table: \"Person\""
  insert_Person_one(
    "the row to be inserted"
    object: Person_insert_input!,
    "on conflict condition"
    on_conflict: Person_on_conflict
  ): Person
  "insert data into the table: \"Project\""
  insert_Project(
    "the rows to be inserted"
    objects: [Project_insert_input!]!,
    "on conflict condition"
    on_conflict: Project_on_conflict
  ): Project_mutation_response
  "insert data into the table: \"ProjectContributor\""
  insert_ProjectContributor(
    "the rows to be inserted"
    objects: [ProjectContributor_insert_input!]!,
    "on conflict condition"
    on_conflict: ProjectContributor_on_conflict
  ): ProjectContributor_mutation_response
  "insert a single row into the table: \"ProjectContributor\""
  insert_ProjectContributor_one(
    "the row to be inserted"
    object: ProjectContributor_insert_input!,
    "on conflict condition"
    on_conflict: ProjectContributor_on_conflict
  ): ProjectContributor
  "insert a single row into the table: \"Project\""
  insert_Project_one(
    "the row to be inserted"
    object: Project_insert_input!,
    "on conflict condition"
    on_conflict: Project_on_conflict
  ): Project
  "insert data into the table: \"School\""
  insert_School(
    "the rows to be inserted"
    objects: [School_insert_input!]!,
    "on conflict condition"
    on_conflict: School_on_conflict
  ): School_mutation_response
  "insert a single row into the table: \"School\""
  insert_School_one(
    "the row to be inserted"
    object: School_insert_input!,
    "on conflict condition"
    on_conflict: School_on_conflict
  ): School
  "insert data into the table: \"TechnologyLogo\""
  insert_TechnologyLogo(
    "the rows to be inserted"
    objects: [TechnologyLogo_insert_input!]!,
    "on conflict condition"
    on_conflict: TechnologyLogo_on_conflict
  ): TechnologyLogo_mutation_response
  "insert a single row into the table: \"TechnologyLogo\""
  insert_TechnologyLogo_one(
    "the row to be inserted"
    object: TechnologyLogo_insert_input!,
    "on conflict condition"
    on_conflict: TechnologyLogo_on_conflict
  ): TechnologyLogo
  "insert data into the table: \"User\""
  insert_User(
    "the rows to be inserted"
    objects: [User_insert_input!]!,
    "on conflict condition"
    on_conflict: User_on_conflict
  ): User_mutation_response
  "insert a single row into the table: \"User\""
  insert_User_one(
    "the row to be inserted"
    object: User_insert_input!,
    "on conflict condition"
    on_conflict: User_on_conflict
  ): User
  "update data of the table: \"Blog\""
  update_Blog(
    "sets the columns of the filtered rows to the given values"
    _set: Blog_set_input,
    "filter the rows which have to be updated"
    where: Blog_bool_exp!
  ): Blog_mutation_response
  "update data of the table: \"BlogAuthor\""
  update_BlogAuthor(
    "sets the columns of the filtered rows to the given values"
    _set: BlogAuthor_set_input,
    "filter the rows which have to be updated"
    where: BlogAuthor_bool_exp!
  ): BlogAuthor_mutation_response
  "update single row of the table: \"BlogAuthor\""
  update_BlogAuthor_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: BlogAuthor_set_input,
    pk_columns: BlogAuthor_pk_columns_input!
  ): BlogAuthor
  "update single row of the table: \"Blog\""
  update_Blog_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: Blog_set_input,
    pk_columns: Blog_pk_columns_input!
  ): Blog
  "update data of the table: \"Course\""
  update_Course(
    "increments the numeric columns with given value of the filtered values"
    _inc: Course_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: Course_set_input,
    "filter the rows which have to be updated"
    where: Course_bool_exp!
  ): Course_mutation_response
  "update data of the table: \"CourseInstructor\""
  update_CourseInstructor(
    "sets the columns of the filtered rows to the given values"
    _set: CourseInstructor_set_input,
    "filter the rows which have to be updated"
    where: CourseInstructor_bool_exp!
  ): CourseInstructor_mutation_response
  "update single row of the table: \"CourseInstructor\""
  update_CourseInstructor_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: CourseInstructor_set_input,
    pk_columns: CourseInstructor_pk_columns_input!
  ): CourseInstructor
  "update data of the table: \"CourseUrl\""
  update_CourseUrl(
    "sets the columns of the filtered rows to the given values"
    _set: CourseUrl_set_input,
    "filter the rows which have to be updated"
    where: CourseUrl_bool_exp!
  ): CourseUrl_mutation_response
  "update single row of the table: \"CourseUrl\""
  update_CourseUrl_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: CourseUrl_set_input,
    pk_columns: CourseUrl_pk_columns_input!
  ): CourseUrl
  "update single row of the table: \"Course\""
  update_Course_by_pk(
    "increments the numeric columns with given value of the filtered values"
    _inc: Course_inc_input,
    "sets the columns of the filtered rows to the given values"
    _set: Course_set_input,
    pk_columns: Course_pk_columns_input!
  ): Course
  "update data of the table: \"Image\""
  update_Image(
    "sets the columns of the filtered rows to the given values"
    _set: Image_set_input,
    "filter the rows which have to be updated"
    where: Image_bool_exp!
  ): Image_mutation_response
  "update single row of the table: \"Image\""
  update_Image_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: Image_set_input,
    pk_columns: Image_pk_columns_input!
  ): Image
  "update data of the table: \"Person\""
  update_Person(
    "sets the columns of the filtered rows to the given values"
    _set: Person_set_input,
    "filter the rows which have to be updated"
    where: Person_bool_exp!
  ): Person_mutation_response
  "update single row of the table: \"Person\""
  update_Person_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: Person_set_input,
    pk_columns: Person_pk_columns_input!
  ): Person
  "update data of the table: \"Project\""
  update_Project(
    "sets the columns of the filtered rows to the given values"
    _set: Project_set_input,
    "filter the rows which have to be updated"
    where: Project_bool_exp!
  ): Project_mutation_response
  "update data of the table: \"ProjectContributor\""
  update_ProjectContributor(
    "sets the columns of the filtered rows to the given values"
    _set: ProjectContributor_set_input,
    "filter the rows which have to be updated"
    where: ProjectContributor_bool_exp!
  ): ProjectContributor_mutation_response
  "update single row of the table: \"ProjectContributor\""
  update_ProjectContributor_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: ProjectContributor_set_input,
    pk_columns: ProjectContributor_pk_columns_input!
  ): ProjectContributor
  "update single row of the table: \"Project\""
  update_Project_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: Project_set_input,
    pk_columns: Project_pk_columns_input!
  ): Project
  "update data of the table: \"School\""
  update_School(
    "sets the columns of the filtered rows to the given values"
    _set: School_set_input,
    "filter the rows which have to be updated"
    where: School_bool_exp!
  ): School_mutation_response
  "update single row of the table: \"School\""
  update_School_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: School_set_input,
    pk_columns: School_pk_columns_input!
  ): School
  "update data of the table: \"TechnologyLogo\""
  update_TechnologyLogo(
    "sets the columns of the filtered rows to the given values"
    _set: TechnologyLogo_set_input,
    "filter the rows which have to be updated"
    where: TechnologyLogo_bool_exp!
  ): TechnologyLogo_mutation_response
  "update single row of the table: \"TechnologyLogo\""
  update_TechnologyLogo_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: TechnologyLogo_set_input,
    pk_columns: TechnologyLogo_pk_columns_input!
  ): TechnologyLogo
  "update data of the table: \"User\""
  update_User(
    "sets the columns of the filtered rows to the given values"
    _set: User_set_input,
    "filter the rows which have to be updated"
    where: User_bool_exp!
  ): User_mutation_response
  "update single row of the table: \"User\""
  update_User_by_pk(
    "sets the columns of the filtered rows to the given values"
    _set: User_set_input,
    pk_columns: User_pk_columns_input!
  ): User
}

type query_root {
  "fetch data from the table: \"Blog\""
  Blog(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): [Blog!]!
  "fetch data from the table: \"BlogAuthor\""
  BlogAuthor(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): [BlogAuthor!]!
  "fetch aggregated fields from the table: \"BlogAuthor\""
  BlogAuthor_aggregate(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): BlogAuthor_aggregate!
  "fetch data from the table: \"BlogAuthor\" using primary key columns"
  BlogAuthor_by_pk(id: uuid!): BlogAuthor
  "fetch aggregated fields from the table: \"Blog\""
  Blog_aggregate(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): Blog_aggregate!
  "fetch data from the table: \"Blog\" using primary key columns"
  Blog_by_pk(id: uuid!): Blog
  "fetch data from the table: \"Course\""
  Course(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): [Course!]!
  "fetch data from the table: \"CourseInstructor\""
  CourseInstructor(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): [CourseInstructor!]!
  "fetch aggregated fields from the table: \"CourseInstructor\""
  CourseInstructor_aggregate(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): CourseInstructor_aggregate!
  "fetch data from the table: \"CourseInstructor\" using primary key columns"
  CourseInstructor_by_pk(id: uuid!): CourseInstructor
  "fetch data from the table: \"CourseUrl\""
  CourseUrl(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): [CourseUrl!]!
  "fetch aggregated fields from the table: \"CourseUrl\""
  CourseUrl_aggregate(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): CourseUrl_aggregate!
  "fetch data from the table: \"CourseUrl\" using primary key columns"
  CourseUrl_by_pk(id: uuid!): CourseUrl
  "fetch aggregated fields from the table: \"Course\""
  Course_aggregate(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): Course_aggregate!
  "fetch data from the table: \"Course\" using primary key columns"
  Course_by_pk(id: uuid!): Course
  "fetch data from the table: \"Image\""
  Image(
    "distinct select on columns"
    distinct_on: [Image_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Image_order_by!],
    "filter the rows returned"
    where: Image_bool_exp
  ): [Image!]!
  "fetch aggregated fields from the table: \"Image\""
  Image_aggregate(
    "distinct select on columns"
    distinct_on: [Image_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Image_order_by!],
    "filter the rows returned"
    where: Image_bool_exp
  ): Image_aggregate!
  "fetch data from the table: \"Image\" using primary key columns"
  Image_by_pk(id: uuid!): Image
  "fetch data from the table: \"Person\""
  Person(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): [Person!]!
  "fetch aggregated fields from the table: \"Person\""
  Person_aggregate(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): Person_aggregate!
  "fetch data from the table: \"Person\" using primary key columns"
  Person_by_pk(id: uuid!): Person
  "fetch data from the table: \"Project\""
  Project(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): [Project!]!
  "fetch data from the table: \"ProjectContributor\""
  ProjectContributor(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): [ProjectContributor!]!
  "fetch aggregated fields from the table: \"ProjectContributor\""
  ProjectContributor_aggregate(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): ProjectContributor_aggregate!
  "fetch data from the table: \"ProjectContributor\" using primary key columns"
  ProjectContributor_by_pk(id: uuid!): ProjectContributor
  "fetch aggregated fields from the table: \"Project\""
  Project_aggregate(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): Project_aggregate!
  "fetch data from the table: \"Project\" using primary key columns"
  Project_by_pk(id: uuid!): Project
  "fetch data from the table: \"School\""
  School(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): [School!]!
  "fetch aggregated fields from the table: \"School\""
  School_aggregate(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): School_aggregate!
  "fetch data from the table: \"School\" using primary key columns"
  School_by_pk(id: uuid!): School
  "fetch data from the table: \"TechnologyLogo\""
  TechnologyLogo(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): [TechnologyLogo!]!
  "fetch aggregated fields from the table: \"TechnologyLogo\""
  TechnologyLogo_aggregate(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): TechnologyLogo_aggregate!
  "fetch data from the table: \"TechnologyLogo\" using primary key columns"
  TechnologyLogo_by_pk(id: uuid!): TechnologyLogo
  "fetch data from the table: \"User\""
  User(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): [User!]!
  "fetch aggregated fields from the table: \"User\""
  User_aggregate(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): User_aggregate!
  "fetch data from the table: \"User\" using primary key columns"
  User_by_pk(id: uuid!): User
}

type subscription_root {
  "fetch data from the table: \"Blog\""
  Blog(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): [Blog!]!
  "fetch data from the table: \"BlogAuthor\""
  BlogAuthor(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): [BlogAuthor!]!
  "fetch aggregated fields from the table: \"BlogAuthor\""
  BlogAuthor_aggregate(
    "distinct select on columns"
    distinct_on: [BlogAuthor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [BlogAuthor_order_by!],
    "filter the rows returned"
    where: BlogAuthor_bool_exp
  ): BlogAuthor_aggregate!
  "fetch data from the table: \"BlogAuthor\" using primary key columns"
  BlogAuthor_by_pk(id: uuid!): BlogAuthor
  "fetch aggregated fields from the table: \"Blog\""
  Blog_aggregate(
    "distinct select on columns"
    distinct_on: [Blog_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Blog_order_by!],
    "filter the rows returned"
    where: Blog_bool_exp
  ): Blog_aggregate!
  "fetch data from the table: \"Blog\" using primary key columns"
  Blog_by_pk(id: uuid!): Blog
  "fetch data from the table: \"Course\""
  Course(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): [Course!]!
  "fetch data from the table: \"CourseInstructor\""
  CourseInstructor(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): [CourseInstructor!]!
  "fetch aggregated fields from the table: \"CourseInstructor\""
  CourseInstructor_aggregate(
    "distinct select on columns"
    distinct_on: [CourseInstructor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseInstructor_order_by!],
    "filter the rows returned"
    where: CourseInstructor_bool_exp
  ): CourseInstructor_aggregate!
  "fetch data from the table: \"CourseInstructor\" using primary key columns"
  CourseInstructor_by_pk(id: uuid!): CourseInstructor
  "fetch data from the table: \"CourseUrl\""
  CourseUrl(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): [CourseUrl!]!
  "fetch aggregated fields from the table: \"CourseUrl\""
  CourseUrl_aggregate(
    "distinct select on columns"
    distinct_on: [CourseUrl_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [CourseUrl_order_by!],
    "filter the rows returned"
    where: CourseUrl_bool_exp
  ): CourseUrl_aggregate!
  "fetch data from the table: \"CourseUrl\" using primary key columns"
  CourseUrl_by_pk(id: uuid!): CourseUrl
  "fetch aggregated fields from the table: \"Course\""
  Course_aggregate(
    "distinct select on columns"
    distinct_on: [Course_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Course_order_by!],
    "filter the rows returned"
    where: Course_bool_exp
  ): Course_aggregate!
  "fetch data from the table: \"Course\" using primary key columns"
  Course_by_pk(id: uuid!): Course
  "fetch data from the table: \"Image\""
  Image(
    "distinct select on columns"
    distinct_on: [Image_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Image_order_by!],
    "filter the rows returned"
    where: Image_bool_exp
  ): [Image!]!
  "fetch aggregated fields from the table: \"Image\""
  Image_aggregate(
    "distinct select on columns"
    distinct_on: [Image_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Image_order_by!],
    "filter the rows returned"
    where: Image_bool_exp
  ): Image_aggregate!
  "fetch data from the table: \"Image\" using primary key columns"
  Image_by_pk(id: uuid!): Image
  "fetch data from the table: \"Person\""
  Person(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): [Person!]!
  "fetch aggregated fields from the table: \"Person\""
  Person_aggregate(
    "distinct select on columns"
    distinct_on: [Person_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Person_order_by!],
    "filter the rows returned"
    where: Person_bool_exp
  ): Person_aggregate!
  "fetch data from the table: \"Person\" using primary key columns"
  Person_by_pk(id: uuid!): Person
  "fetch data from the table: \"Project\""
  Project(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): [Project!]!
  "fetch data from the table: \"ProjectContributor\""
  ProjectContributor(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): [ProjectContributor!]!
  "fetch aggregated fields from the table: \"ProjectContributor\""
  ProjectContributor_aggregate(
    "distinct select on columns"
    distinct_on: [ProjectContributor_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [ProjectContributor_order_by!],
    "filter the rows returned"
    where: ProjectContributor_bool_exp
  ): ProjectContributor_aggregate!
  "fetch data from the table: \"ProjectContributor\" using primary key columns"
  ProjectContributor_by_pk(id: uuid!): ProjectContributor
  "fetch aggregated fields from the table: \"Project\""
  Project_aggregate(
    "distinct select on columns"
    distinct_on: [Project_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [Project_order_by!],
    "filter the rows returned"
    where: Project_bool_exp
  ): Project_aggregate!
  "fetch data from the table: \"Project\" using primary key columns"
  Project_by_pk(id: uuid!): Project
  "fetch data from the table: \"School\""
  School(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): [School!]!
  "fetch aggregated fields from the table: \"School\""
  School_aggregate(
    "distinct select on columns"
    distinct_on: [School_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [School_order_by!],
    "filter the rows returned"
    where: School_bool_exp
  ): School_aggregate!
  "fetch data from the table: \"School\" using primary key columns"
  School_by_pk(id: uuid!): School
  "fetch data from the table: \"TechnologyLogo\""
  TechnologyLogo(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): [TechnologyLogo!]!
  "fetch aggregated fields from the table: \"TechnologyLogo\""
  TechnologyLogo_aggregate(
    "distinct select on columns"
    distinct_on: [TechnologyLogo_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [TechnologyLogo_order_by!],
    "filter the rows returned"
    where: TechnologyLogo_bool_exp
  ): TechnologyLogo_aggregate!
  "fetch data from the table: \"TechnologyLogo\" using primary key columns"
  TechnologyLogo_by_pk(id: uuid!): TechnologyLogo
  "fetch data from the table: \"User\""
  User(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): [User!]!
  "fetch aggregated fields from the table: \"User\""
  User_aggregate(
    "distinct select on columns"
    distinct_on: [User_select_column!],
    "limit the number of rows returned"
    limit: Int,
    "skip the first n rows. Use only with order_by"
    offset: Int,
    "sort the rows by one or more columns"
    order_by: [User_order_by!],
    "filter the rows returned"
    where: User_bool_exp
  ): User_aggregate!
  "fetch data from the table: \"User\" using primary key columns"
  User_by_pk(id: uuid!): User
}

"unique or primary key constraints on table \"BlogAuthor\""
enum BlogAuthor_constraint {
  "unique or primary key constraint"
  BlogAuthor_pkey
}

"select columns of table \"BlogAuthor\""
enum BlogAuthor_select_column {
  "column name"
  blogId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  personId
  "column name"
  updatedAt
}

"update columns of table \"BlogAuthor\""
enum BlogAuthor_update_column {
  "column name"
  blogId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  personId
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"Blog\""
enum Blog_constraint {
  "unique or primary key constraint"
  Blog_pkey
  "unique or primary key constraint"
  Blog_slug_key
}

"select columns of table \"Blog\""
enum Blog_select_column {
  "column name"
  content
  "column name"
  createdAt
  "column name"
  id
  "column name"
  imageId
  "column name"
  slug
  "column name"
  title
  "column name"
  updatedAt
}

"update columns of table \"Blog\""
enum Blog_update_column {
  "column name"
  content
  "column name"
  createdAt
  "column name"
  id
  "column name"
  imageId
  "column name"
  slug
  "column name"
  title
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"CourseInstructor\""
enum CourseInstructor_constraint {
  "unique or primary key constraint"
  CourseInstructor_pkey
}

"select columns of table \"CourseInstructor\""
enum CourseInstructor_select_column {
  "column name"
  courseId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  instructorId
  "column name"
  updatedAt
}

"update columns of table \"CourseInstructor\""
enum CourseInstructor_update_column {
  "column name"
  courseId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  instructorId
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"CourseUrl\""
enum CourseUrl_constraint {
  "unique or primary key constraint"
  CourseUrl_courseId_url_schoolId_key
  "unique or primary key constraint"
  CourseUrl_pkey
  "unique or primary key constraint"
  CourseUrl_url_key
}

"select columns of table \"CourseUrl\""
enum CourseUrl_select_column {
  "column name"
  courseId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  schoolId
  "column name"
  updatedAt
  "column name"
  url
}

"update columns of table \"CourseUrl\""
enum CourseUrl_update_column {
  "column name"
  courseId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  schoolId
  "column name"
  updatedAt
  "column name"
  url
}

"unique or primary key constraints on table \"Course\""
enum Course_constraint {
  "unique or primary key constraint"
  Course_pkey
}

"select columns of table \"Course\""
enum Course_select_column {
  "column name"
  complete
  "column name"
  createdAt
  "column name"
  duration
  "column name"
  id
  "column name"
  order
  "column name"
  rating
  "column name"
  ratingUrl
  "column name"
  recommended
  "column name"
  schoolId
  "column name"
  title
  "column name"
  updatedAt
  "column name"
  yearUpdated
}

"update columns of table \"Course\""
enum Course_update_column {
  "column name"
  complete
  "column name"
  createdAt
  "column name"
  duration
  "column name"
  id
  "column name"
  order
  "column name"
  rating
  "column name"
  ratingUrl
  "column name"
  recommended
  "column name"
  schoolId
  "column name"
  title
  "column name"
  updatedAt
  "column name"
  yearUpdated
}

"unique or primary key constraints on table \"Image\""
enum Image_constraint {
  "unique or primary key constraint"
  Image_pkey
  "unique or primary key constraint"
  Image_url_key
}

"select columns of table \"Image\""
enum Image_select_column {
  "column name"
  altText
  "column name"
  createdAt
  "column name"
  height
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  url
  "column name"
  width
}

"update columns of table \"Image\""
enum Image_update_column {
  "column name"
  altText
  "column name"
  createdAt
  "column name"
  height
  "column name"
  id
  "column name"
  updatedAt
  "column name"
  url
  "column name"
  width
}

"unique or primary key constraints on table \"Person\""
enum Person_constraint {
  "unique or primary key constraint"
  Person_pkey
}

"select columns of table \"Person\""
enum Person_select_column {
  "column name"
  createdAt
  "column name"
  firstName
  "column name"
  githubUrl
  "column name"
  id
  "column name"
  imageId
  "column name"
  lastName
  "column name"
  linkedinUrl
  "column name"
  summary
  "column name"
  updatedAt
  "column name"
  websiteUrl
}

"update columns of table \"Person\""
enum Person_update_column {
  "column name"
  createdAt
  "column name"
  firstName
  "column name"
  githubUrl
  "column name"
  id
  "column name"
  imageId
  "column name"
  lastName
  "column name"
  linkedinUrl
  "column name"
  summary
  "column name"
  updatedAt
  "column name"
  websiteUrl
}

"unique or primary key constraints on table \"ProjectContributor\""
enum ProjectContributor_constraint {
  "unique or primary key constraint"
  ProjectContributor_pkey
}

"select columns of table \"ProjectContributor\""
enum ProjectContributor_select_column {
  "column name"
  contributorId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  projectId
  "column name"
  updatedAt
}

"update columns of table \"ProjectContributor\""
enum ProjectContributor_update_column {
  "column name"
  contributorId
  "column name"
  createdAt
  "column name"
  id
  "column name"
  projectId
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"Project\""
enum Project_constraint {
  "unique or primary key constraint"
  Project_pkey
  "unique or primary key constraint"
  Project_slug_key
}

"select columns of table \"Project\""
enum Project_select_column {
  "column name"
  createdAt
  "column name"
  githubUrl
  "column name"
  id
  "column name"
  imageId
  "column name"
  name
  "column name"
  projectUrl
  "column name"
  slug
  "column name"
  summary
  "column name"
  updatedAt
}

"update columns of table \"Project\""
enum Project_update_column {
  "column name"
  createdAt
  "column name"
  githubUrl
  "column name"
  id
  "column name"
  imageId
  "column name"
  name
  "column name"
  projectUrl
  "column name"
  slug
  "column name"
  summary
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"School\""
enum School_constraint {
  "unique or primary key constraint"
  School_pkey
  "unique or primary key constraint"
  School_url_key
}

"select columns of table \"School\""
enum School_select_column {
  "column name"
  createdAt
  "column name"
  description
  "column name"
  id
  "column name"
  imageId
  "column name"
  name
  "column name"
  updatedAt
  "column name"
  url
}

"update columns of table \"School\""
enum School_update_column {
  "column name"
  createdAt
  "column name"
  description
  "column name"
  id
  "column name"
  imageId
  "column name"
  name
  "column name"
  updatedAt
  "column name"
  url
}

"unique or primary key constraints on table \"TechnologyLogo\""
enum TechnologyLogo_constraint {
  "unique or primary key constraint"
  TechnologyLogo_imageId_key
  "unique or primary key constraint"
  TechnologyLogo_pkey
}

"select columns of table \"TechnologyLogo\""
enum TechnologyLogo_select_column {
  "column name"
  createdAt
  "column name"
  id
  "column name"
  imageId
  "column name"
  isOnHomepage
  "column name"
  name
  "column name"
  updatedAt
}

"update columns of table \"TechnologyLogo\""
enum TechnologyLogo_update_column {
  "column name"
  createdAt
  "column name"
  id
  "column name"
  imageId
  "column name"
  isOnHomepage
  "column name"
  name
  "column name"
  updatedAt
}

"unique or primary key constraints on table \"User\""
enum User_constraint {
  "unique or primary key constraint"
  UserCredentials_username_password_unique_constraint
  "unique or primary key constraint"
  User_pkey
  "unique or primary key constraint"
  User_username_key
}

"select columns of table \"User\""
enum User_select_column {
  "column name"
  createdAt
  "column name"
  id
  "column name"
  password
  "column name"
  personId
  "column name"
  role
  "column name"
  updatedAt
  "column name"
  username
}

"update columns of table \"User\""
enum User_update_column {
  "column name"
  createdAt
  "column name"
  id
  "column name"
  password
  "column name"
  personId
  "column name"
  role
  "column name"
  updatedAt
  "column name"
  username
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

scalar Rating

scalar Role

scalar float8

scalar timestamp

scalar uuid

"order by aggregate values of table \"BlogAuthor\""
input BlogAuthor_aggregate_order_by {
  count: order_by
  max: BlogAuthor_max_order_by
  min: BlogAuthor_min_order_by
}

"input type for inserting array relation for remote table \"BlogAuthor\""
input BlogAuthor_arr_rel_insert_input {
  data: [BlogAuthor_insert_input!]!
  "on conflict condition"
  on_conflict: BlogAuthor_on_conflict
}

"Boolean expression to filter rows from the table \"BlogAuthor\". All fields are combined with a logical 'AND'."
input BlogAuthor_bool_exp {
  Blog: Blog_bool_exp
  Person: Person_bool_exp
  _and: [BlogAuthor_bool_exp!]
  _not: BlogAuthor_bool_exp
  _or: [BlogAuthor_bool_exp!]
  blogId: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  personId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"BlogAuthor\""
input BlogAuthor_insert_input {
  Blog: Blog_obj_rel_insert_input
  Person: Person_obj_rel_insert_input
  blogId: uuid
  createdAt: timestamp
  id: uuid
  personId: uuid
  updatedAt: timestamp
}

"order by max() on columns of table \"BlogAuthor\""
input BlogAuthor_max_order_by {
  blogId: order_by
  createdAt: order_by
  id: order_by
  personId: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"BlogAuthor\""
input BlogAuthor_min_order_by {
  blogId: order_by
  createdAt: order_by
  id: order_by
  personId: order_by
  updatedAt: order_by
}

"on conflict condition type for table \"BlogAuthor\""
input BlogAuthor_on_conflict {
  constraint: BlogAuthor_constraint!
  update_columns: [BlogAuthor_update_column!]! = []
  where: BlogAuthor_bool_exp
}

"Ordering options when selecting data from \"BlogAuthor\"."
input BlogAuthor_order_by {
  Blog: Blog_order_by
  Person: Person_order_by
  blogId: order_by
  createdAt: order_by
  id: order_by
  personId: order_by
  updatedAt: order_by
}

"primary key columns input for table: BlogAuthor"
input BlogAuthor_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"BlogAuthor\""
input BlogAuthor_set_input {
  blogId: uuid
  createdAt: timestamp
  id: uuid
  personId: uuid
  updatedAt: timestamp
}

"order by aggregate values of table \"Blog\""
input Blog_aggregate_order_by {
  count: order_by
  max: Blog_max_order_by
  min: Blog_min_order_by
}

"input type for inserting array relation for remote table \"Blog\""
input Blog_arr_rel_insert_input {
  data: [Blog_insert_input!]!
  "on conflict condition"
  on_conflict: Blog_on_conflict
}

"Boolean expression to filter rows from the table \"Blog\". All fields are combined with a logical 'AND'."
input Blog_bool_exp {
  BlogAuthors: BlogAuthor_bool_exp
  Image: Image_bool_exp
  _and: [Blog_bool_exp!]
  _not: Blog_bool_exp
  _or: [Blog_bool_exp!]
  content: String_comparison_exp
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  imageId: uuid_comparison_exp
  slug: String_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"Blog\""
input Blog_insert_input {
  BlogAuthors: BlogAuthor_arr_rel_insert_input
  Image: Image_obj_rel_insert_input
  content: String
  createdAt: timestamp
  id: uuid
  imageId: uuid
  slug: String
  title: String
  updatedAt: timestamp
}

"order by max() on columns of table \"Blog\""
input Blog_max_order_by {
  content: order_by
  createdAt: order_by
  id: order_by
  imageId: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"Blog\""
input Blog_min_order_by {
  content: order_by
  createdAt: order_by
  id: order_by
  imageId: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
}

"input type for inserting object relation for remote table \"Blog\""
input Blog_obj_rel_insert_input {
  data: Blog_insert_input!
  "on conflict condition"
  on_conflict: Blog_on_conflict
}

"on conflict condition type for table \"Blog\""
input Blog_on_conflict {
  constraint: Blog_constraint!
  update_columns: [Blog_update_column!]! = []
  where: Blog_bool_exp
}

"Ordering options when selecting data from \"Blog\"."
input Blog_order_by {
  BlogAuthors_aggregate: BlogAuthor_aggregate_order_by
  Image: Image_order_by
  content: order_by
  createdAt: order_by
  id: order_by
  imageId: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
}

"primary key columns input for table: Blog"
input Blog_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"Blog\""
input Blog_set_input {
  content: String
  createdAt: timestamp
  id: uuid
  imageId: uuid
  slug: String
  title: String
  updatedAt: timestamp
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"order by aggregate values of table \"CourseInstructor\""
input CourseInstructor_aggregate_order_by {
  count: order_by
  max: CourseInstructor_max_order_by
  min: CourseInstructor_min_order_by
}

"input type for inserting array relation for remote table \"CourseInstructor\""
input CourseInstructor_arr_rel_insert_input {
  data: [CourseInstructor_insert_input!]!
  "on conflict condition"
  on_conflict: CourseInstructor_on_conflict
}

"Boolean expression to filter rows from the table \"CourseInstructor\". All fields are combined with a logical 'AND'."
input CourseInstructor_bool_exp {
  Course: Course_bool_exp
  Person: Person_bool_exp
  _and: [CourseInstructor_bool_exp!]
  _not: CourseInstructor_bool_exp
  _or: [CourseInstructor_bool_exp!]
  courseId: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  instructorId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"CourseInstructor\""
input CourseInstructor_insert_input {
  Course: Course_obj_rel_insert_input
  Person: Person_obj_rel_insert_input
  courseId: uuid
  createdAt: timestamp
  id: uuid
  instructorId: uuid
  updatedAt: timestamp
}

"order by max() on columns of table \"CourseInstructor\""
input CourseInstructor_max_order_by {
  courseId: order_by
  createdAt: order_by
  id: order_by
  instructorId: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"CourseInstructor\""
input CourseInstructor_min_order_by {
  courseId: order_by
  createdAt: order_by
  id: order_by
  instructorId: order_by
  updatedAt: order_by
}

"on conflict condition type for table \"CourseInstructor\""
input CourseInstructor_on_conflict {
  constraint: CourseInstructor_constraint!
  update_columns: [CourseInstructor_update_column!]! = []
  where: CourseInstructor_bool_exp
}

"Ordering options when selecting data from \"CourseInstructor\"."
input CourseInstructor_order_by {
  Course: Course_order_by
  Person: Person_order_by
  courseId: order_by
  createdAt: order_by
  id: order_by
  instructorId: order_by
  updatedAt: order_by
}

"primary key columns input for table: CourseInstructor"
input CourseInstructor_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"CourseInstructor\""
input CourseInstructor_set_input {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  instructorId: uuid
  updatedAt: timestamp
}

"order by aggregate values of table \"CourseUrl\""
input CourseUrl_aggregate_order_by {
  count: order_by
  max: CourseUrl_max_order_by
  min: CourseUrl_min_order_by
}

"input type for inserting array relation for remote table \"CourseUrl\""
input CourseUrl_arr_rel_insert_input {
  data: [CourseUrl_insert_input!]!
  "on conflict condition"
  on_conflict: CourseUrl_on_conflict
}

"Boolean expression to filter rows from the table \"CourseUrl\". All fields are combined with a logical 'AND'."
input CourseUrl_bool_exp {
  Course: Course_bool_exp
  School: School_bool_exp
  _and: [CourseUrl_bool_exp!]
  _not: CourseUrl_bool_exp
  _or: [CourseUrl_bool_exp!]
  courseId: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  schoolId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
  url: String_comparison_exp
}

"input type for inserting data into table \"CourseUrl\""
input CourseUrl_insert_input {
  Course: Course_obj_rel_insert_input
  School: School_obj_rel_insert_input
  courseId: uuid
  createdAt: timestamp
  id: uuid
  schoolId: uuid
  updatedAt: timestamp
  url: String
}

"order by max() on columns of table \"CourseUrl\""
input CourseUrl_max_order_by {
  courseId: order_by
  createdAt: order_by
  id: order_by
  schoolId: order_by
  updatedAt: order_by
  url: order_by
}

"order by min() on columns of table \"CourseUrl\""
input CourseUrl_min_order_by {
  courseId: order_by
  createdAt: order_by
  id: order_by
  schoolId: order_by
  updatedAt: order_by
  url: order_by
}

"on conflict condition type for table \"CourseUrl\""
input CourseUrl_on_conflict {
  constraint: CourseUrl_constraint!
  update_columns: [CourseUrl_update_column!]! = []
  where: CourseUrl_bool_exp
}

"Ordering options when selecting data from \"CourseUrl\"."
input CourseUrl_order_by {
  Course: Course_order_by
  School: School_order_by
  courseId: order_by
  createdAt: order_by
  id: order_by
  schoolId: order_by
  updatedAt: order_by
  url: order_by
}

"primary key columns input for table: CourseUrl"
input CourseUrl_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"CourseUrl\""
input CourseUrl_set_input {
  courseId: uuid
  createdAt: timestamp
  id: uuid
  schoolId: uuid
  updatedAt: timestamp
  url: String
}

"order by aggregate values of table \"Course\""
input Course_aggregate_order_by {
  avg: Course_avg_order_by
  count: order_by
  max: Course_max_order_by
  min: Course_min_order_by
  stddev: Course_stddev_order_by
  stddev_pop: Course_stddev_pop_order_by
  stddev_samp: Course_stddev_samp_order_by
  sum: Course_sum_order_by
  var_pop: Course_var_pop_order_by
  var_samp: Course_var_samp_order_by
  variance: Course_variance_order_by
}

"input type for inserting array relation for remote table \"Course\""
input Course_arr_rel_insert_input {
  data: [Course_insert_input!]!
  "on conflict condition"
  on_conflict: Course_on_conflict
}

"order by avg() on columns of table \"Course\""
input Course_avg_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"Boolean expression to filter rows from the table \"Course\". All fields are combined with a logical 'AND'."
input Course_bool_exp {
  CourseInstructors: CourseInstructor_bool_exp
  CourseUrls: CourseUrl_bool_exp
  School: School_bool_exp
  _and: [Course_bool_exp!]
  _not: Course_bool_exp
  _or: [Course_bool_exp!]
  complete: Boolean_comparison_exp
  createdAt: timestamp_comparison_exp
  duration: float8_comparison_exp
  id: uuid_comparison_exp
  order: Int_comparison_exp
  rating: Rating_comparison_exp
  ratingUrl: String_comparison_exp
  recommended: Boolean_comparison_exp
  schoolId: uuid_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  yearUpdated: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"Course\""
input Course_inc_input {
  duration: float8
  order: Int
  yearUpdated: Int
}

"input type for inserting data into table \"Course\""
input Course_insert_input {
  CourseInstructors: CourseInstructor_arr_rel_insert_input
  CourseUrls: CourseUrl_arr_rel_insert_input
  School: School_obj_rel_insert_input
  complete: Boolean
  createdAt: timestamp
  duration: float8
  id: uuid
  order: Int
  rating: Rating
  ratingUrl: String
  recommended: Boolean
  schoolId: uuid
  title: String
  updatedAt: timestamp
  yearUpdated: Int
}

"order by max() on columns of table \"Course\""
input Course_max_order_by {
  createdAt: order_by
  duration: order_by
  id: order_by
  order: order_by
  ratingUrl: order_by
  schoolId: order_by
  title: order_by
  updatedAt: order_by
  yearUpdated: order_by
}

"order by min() on columns of table \"Course\""
input Course_min_order_by {
  createdAt: order_by
  duration: order_by
  id: order_by
  order: order_by
  ratingUrl: order_by
  schoolId: order_by
  title: order_by
  updatedAt: order_by
  yearUpdated: order_by
}

"input type for inserting object relation for remote table \"Course\""
input Course_obj_rel_insert_input {
  data: Course_insert_input!
  "on conflict condition"
  on_conflict: Course_on_conflict
}

"on conflict condition type for table \"Course\""
input Course_on_conflict {
  constraint: Course_constraint!
  update_columns: [Course_update_column!]! = []
  where: Course_bool_exp
}

"Ordering options when selecting data from \"Course\"."
input Course_order_by {
  CourseInstructors_aggregate: CourseInstructor_aggregate_order_by
  CourseUrls_aggregate: CourseUrl_aggregate_order_by
  School: School_order_by
  complete: order_by
  createdAt: order_by
  duration: order_by
  id: order_by
  order: order_by
  rating: order_by
  ratingUrl: order_by
  recommended: order_by
  schoolId: order_by
  title: order_by
  updatedAt: order_by
  yearUpdated: order_by
}

"primary key columns input for table: Course"
input Course_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"Course\""
input Course_set_input {
  complete: Boolean
  createdAt: timestamp
  duration: float8
  id: uuid
  order: Int
  rating: Rating
  ratingUrl: String
  recommended: Boolean
  schoolId: uuid
  title: String
  updatedAt: timestamp
  yearUpdated: Int
}

"order by stddev() on columns of table \"Course\""
input Course_stddev_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by stddev_pop() on columns of table \"Course\""
input Course_stddev_pop_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by stddev_samp() on columns of table \"Course\""
input Course_stddev_samp_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by sum() on columns of table \"Course\""
input Course_sum_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by var_pop() on columns of table \"Course\""
input Course_var_pop_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by var_samp() on columns of table \"Course\""
input Course_var_samp_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"order by variance() on columns of table \"Course\""
input Course_variance_order_by {
  duration: order_by
  order: order_by
  yearUpdated: order_by
}

"Boolean expression to filter rows from the table \"Image\". All fields are combined with a logical 'AND'."
input Image_bool_exp {
  Blogs: Blog_bool_exp
  People: Person_bool_exp
  Projects: Project_bool_exp
  Schools: School_bool_exp
  TechnologyLogos: TechnologyLogo_bool_exp
  _and: [Image_bool_exp!]
  _not: Image_bool_exp
  _or: [Image_bool_exp!]
  altText: String_comparison_exp
  createdAt: timestamp_comparison_exp
  height: String_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
  url: String_comparison_exp
  width: String_comparison_exp
}

"input type for inserting data into table \"Image\""
input Image_insert_input {
  Blogs: Blog_arr_rel_insert_input
  People: Person_arr_rel_insert_input
  Projects: Project_arr_rel_insert_input
  Schools: School_arr_rel_insert_input
  TechnologyLogos: TechnologyLogo_arr_rel_insert_input
  altText: String
  createdAt: timestamp
  height: String
  id: uuid
  updatedAt: timestamp
  url: String
  width: String
}

"input type for inserting object relation for remote table \"Image\""
input Image_obj_rel_insert_input {
  data: Image_insert_input!
  "on conflict condition"
  on_conflict: Image_on_conflict
}

"on conflict condition type for table \"Image\""
input Image_on_conflict {
  constraint: Image_constraint!
  update_columns: [Image_update_column!]! = []
  where: Image_bool_exp
}

"Ordering options when selecting data from \"Image\"."
input Image_order_by {
  Blogs_aggregate: Blog_aggregate_order_by
  People_aggregate: Person_aggregate_order_by
  Projects_aggregate: Project_aggregate_order_by
  Schools_aggregate: School_aggregate_order_by
  TechnologyLogos_aggregate: TechnologyLogo_aggregate_order_by
  altText: order_by
  createdAt: order_by
  height: order_by
  id: order_by
  updatedAt: order_by
  url: order_by
  width: order_by
}

"primary key columns input for table: Image"
input Image_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"Image\""
input Image_set_input {
  altText: String
  createdAt: timestamp
  height: String
  id: uuid
  updatedAt: timestamp
  url: String
  width: String
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"order by aggregate values of table \"Person\""
input Person_aggregate_order_by {
  count: order_by
  max: Person_max_order_by
  min: Person_min_order_by
}

"input type for inserting array relation for remote table \"Person\""
input Person_arr_rel_insert_input {
  data: [Person_insert_input!]!
  "on conflict condition"
  on_conflict: Person_on_conflict
}

"Boolean expression to filter rows from the table \"Person\". All fields are combined with a logical 'AND'."
input Person_bool_exp {
  BlogAuthors: BlogAuthor_bool_exp
  CourseInstructors: CourseInstructor_bool_exp
  Image: Image_bool_exp
  ProjectContributors: ProjectContributor_bool_exp
  Users: User_bool_exp
  _and: [Person_bool_exp!]
  _not: Person_bool_exp
  _or: [Person_bool_exp!]
  createdAt: timestamp_comparison_exp
  firstName: String_comparison_exp
  githubUrl: String_comparison_exp
  id: uuid_comparison_exp
  imageId: uuid_comparison_exp
  lastName: String_comparison_exp
  linkedinUrl: String_comparison_exp
  summary: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  websiteUrl: String_comparison_exp
}

"input type for inserting data into table \"Person\""
input Person_insert_input {
  BlogAuthors: BlogAuthor_arr_rel_insert_input
  CourseInstructors: CourseInstructor_arr_rel_insert_input
  Image: Image_obj_rel_insert_input
  ProjectContributors: ProjectContributor_arr_rel_insert_input
  Users: User_arr_rel_insert_input
  createdAt: timestamp
  firstName: String
  githubUrl: String
  id: uuid
  imageId: uuid
  lastName: String
  linkedinUrl: String
  summary: String
  updatedAt: timestamp
  websiteUrl: String
}

"order by max() on columns of table \"Person\""
input Person_max_order_by {
  createdAt: order_by
  firstName: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  lastName: order_by
  linkedinUrl: order_by
  summary: order_by
  updatedAt: order_by
  websiteUrl: order_by
}

"order by min() on columns of table \"Person\""
input Person_min_order_by {
  createdAt: order_by
  firstName: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  lastName: order_by
  linkedinUrl: order_by
  summary: order_by
  updatedAt: order_by
  websiteUrl: order_by
}

"input type for inserting object relation for remote table \"Person\""
input Person_obj_rel_insert_input {
  data: Person_insert_input!
  "on conflict condition"
  on_conflict: Person_on_conflict
}

"on conflict condition type for table \"Person\""
input Person_on_conflict {
  constraint: Person_constraint!
  update_columns: [Person_update_column!]! = []
  where: Person_bool_exp
}

"Ordering options when selecting data from \"Person\"."
input Person_order_by {
  BlogAuthors_aggregate: BlogAuthor_aggregate_order_by
  CourseInstructors_aggregate: CourseInstructor_aggregate_order_by
  Image: Image_order_by
  ProjectContributors_aggregate: ProjectContributor_aggregate_order_by
  Users_aggregate: User_aggregate_order_by
  createdAt: order_by
  firstName: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  lastName: order_by
  linkedinUrl: order_by
  summary: order_by
  updatedAt: order_by
  websiteUrl: order_by
}

"primary key columns input for table: Person"
input Person_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"Person\""
input Person_set_input {
  createdAt: timestamp
  firstName: String
  githubUrl: String
  id: uuid
  imageId: uuid
  lastName: String
  linkedinUrl: String
  summary: String
  updatedAt: timestamp
  websiteUrl: String
}

"order by aggregate values of table \"ProjectContributor\""
input ProjectContributor_aggregate_order_by {
  count: order_by
  max: ProjectContributor_max_order_by
  min: ProjectContributor_min_order_by
}

"input type for inserting array relation for remote table \"ProjectContributor\""
input ProjectContributor_arr_rel_insert_input {
  data: [ProjectContributor_insert_input!]!
  "on conflict condition"
  on_conflict: ProjectContributor_on_conflict
}

"Boolean expression to filter rows from the table \"ProjectContributor\". All fields are combined with a logical 'AND'."
input ProjectContributor_bool_exp {
  Person: Person_bool_exp
  Project: Project_bool_exp
  _and: [ProjectContributor_bool_exp!]
  _not: ProjectContributor_bool_exp
  _or: [ProjectContributor_bool_exp!]
  contributorId: uuid_comparison_exp
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  projectId: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"ProjectContributor\""
input ProjectContributor_insert_input {
  Person: Person_obj_rel_insert_input
  Project: Project_obj_rel_insert_input
  contributorId: uuid
  createdAt: timestamp
  id: uuid
  projectId: uuid
  updatedAt: timestamp
}

"order by max() on columns of table \"ProjectContributor\""
input ProjectContributor_max_order_by {
  contributorId: order_by
  createdAt: order_by
  id: order_by
  projectId: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"ProjectContributor\""
input ProjectContributor_min_order_by {
  contributorId: order_by
  createdAt: order_by
  id: order_by
  projectId: order_by
  updatedAt: order_by
}

"on conflict condition type for table \"ProjectContributor\""
input ProjectContributor_on_conflict {
  constraint: ProjectContributor_constraint!
  update_columns: [ProjectContributor_update_column!]! = []
  where: ProjectContributor_bool_exp
}

"Ordering options when selecting data from \"ProjectContributor\"."
input ProjectContributor_order_by {
  Person: Person_order_by
  Project: Project_order_by
  contributorId: order_by
  createdAt: order_by
  id: order_by
  projectId: order_by
  updatedAt: order_by
}

"primary key columns input for table: ProjectContributor"
input ProjectContributor_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"ProjectContributor\""
input ProjectContributor_set_input {
  contributorId: uuid
  createdAt: timestamp
  id: uuid
  projectId: uuid
  updatedAt: timestamp
}

"order by aggregate values of table \"Project\""
input Project_aggregate_order_by {
  count: order_by
  max: Project_max_order_by
  min: Project_min_order_by
}

"input type for inserting array relation for remote table \"Project\""
input Project_arr_rel_insert_input {
  data: [Project_insert_input!]!
  "on conflict condition"
  on_conflict: Project_on_conflict
}

"Boolean expression to filter rows from the table \"Project\". All fields are combined with a logical 'AND'."
input Project_bool_exp {
  Image: Image_bool_exp
  ProjectContributors: ProjectContributor_bool_exp
  _and: [Project_bool_exp!]
  _not: Project_bool_exp
  _or: [Project_bool_exp!]
  createdAt: timestamp_comparison_exp
  githubUrl: String_comparison_exp
  id: uuid_comparison_exp
  imageId: uuid_comparison_exp
  name: String_comparison_exp
  projectUrl: String_comparison_exp
  slug: String_comparison_exp
  summary: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"Project\""
input Project_insert_input {
  Image: Image_obj_rel_insert_input
  ProjectContributors: ProjectContributor_arr_rel_insert_input
  createdAt: timestamp
  githubUrl: String
  id: uuid
  imageId: uuid
  name: String
  projectUrl: String
  slug: String
  summary: String
  updatedAt: timestamp
}

"order by max() on columns of table \"Project\""
input Project_max_order_by {
  createdAt: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  name: order_by
  projectUrl: order_by
  slug: order_by
  summary: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"Project\""
input Project_min_order_by {
  createdAt: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  name: order_by
  projectUrl: order_by
  slug: order_by
  summary: order_by
  updatedAt: order_by
}

"input type for inserting object relation for remote table \"Project\""
input Project_obj_rel_insert_input {
  data: Project_insert_input!
  "on conflict condition"
  on_conflict: Project_on_conflict
}

"on conflict condition type for table \"Project\""
input Project_on_conflict {
  constraint: Project_constraint!
  update_columns: [Project_update_column!]! = []
  where: Project_bool_exp
}

"Ordering options when selecting data from \"Project\"."
input Project_order_by {
  Image: Image_order_by
  ProjectContributors_aggregate: ProjectContributor_aggregate_order_by
  createdAt: order_by
  githubUrl: order_by
  id: order_by
  imageId: order_by
  name: order_by
  projectUrl: order_by
  slug: order_by
  summary: order_by
  updatedAt: order_by
}

"primary key columns input for table: Project"
input Project_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"Project\""
input Project_set_input {
  createdAt: timestamp
  githubUrl: String
  id: uuid
  imageId: uuid
  name: String
  projectUrl: String
  slug: String
  summary: String
  updatedAt: timestamp
}

"Boolean expression to compare columns of type \"Rating\". All fields are combined with logical 'AND'."
input Rating_comparison_exp {
  _eq: Rating
  _gt: Rating
  _gte: Rating
  _in: [Rating!]
  _is_null: Boolean
  _lt: Rating
  _lte: Rating
  _neq: Rating
  _nin: [Rating!]
}

"Boolean expression to compare columns of type \"Role\". All fields are combined with logical 'AND'."
input Role_comparison_exp {
  _eq: Role
  _gt: Role
  _gte: Role
  _in: [Role!]
  _is_null: Boolean
  _lt: Role
  _lte: Role
  _neq: Role
  _nin: [Role!]
}

"order by aggregate values of table \"School\""
input School_aggregate_order_by {
  count: order_by
  max: School_max_order_by
  min: School_min_order_by
}

"input type for inserting array relation for remote table \"School\""
input School_arr_rel_insert_input {
  data: [School_insert_input!]!
  "on conflict condition"
  on_conflict: School_on_conflict
}

"Boolean expression to filter rows from the table \"School\". All fields are combined with a logical 'AND'."
input School_bool_exp {
  CourseUrls: CourseUrl_bool_exp
  Courses: Course_bool_exp
  Image: Image_bool_exp
  _and: [School_bool_exp!]
  _not: School_bool_exp
  _or: [School_bool_exp!]
  createdAt: timestamp_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  imageId: uuid_comparison_exp
  name: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  url: String_comparison_exp
}

"input type for inserting data into table \"School\""
input School_insert_input {
  CourseUrls: CourseUrl_arr_rel_insert_input
  Courses: Course_arr_rel_insert_input
  Image: Image_obj_rel_insert_input
  createdAt: timestamp
  description: String
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
  url: String
}

"order by max() on columns of table \"School\""
input School_max_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  imageId: order_by
  name: order_by
  updatedAt: order_by
  url: order_by
}

"order by min() on columns of table \"School\""
input School_min_order_by {
  createdAt: order_by
  description: order_by
  id: order_by
  imageId: order_by
  name: order_by
  updatedAt: order_by
  url: order_by
}

"input type for inserting object relation for remote table \"School\""
input School_obj_rel_insert_input {
  data: School_insert_input!
  "on conflict condition"
  on_conflict: School_on_conflict
}

"on conflict condition type for table \"School\""
input School_on_conflict {
  constraint: School_constraint!
  update_columns: [School_update_column!]! = []
  where: School_bool_exp
}

"Ordering options when selecting data from \"School\"."
input School_order_by {
  CourseUrls_aggregate: CourseUrl_aggregate_order_by
  Courses_aggregate: Course_aggregate_order_by
  Image: Image_order_by
  createdAt: order_by
  description: order_by
  id: order_by
  imageId: order_by
  name: order_by
  updatedAt: order_by
  url: order_by
}

"primary key columns input for table: School"
input School_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"School\""
input School_set_input {
  createdAt: timestamp
  description: String
  id: uuid
  imageId: uuid
  name: String
  updatedAt: timestamp
  url: String
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"order by aggregate values of table \"TechnologyLogo\""
input TechnologyLogo_aggregate_order_by {
  count: order_by
  max: TechnologyLogo_max_order_by
  min: TechnologyLogo_min_order_by
}

"input type for inserting array relation for remote table \"TechnologyLogo\""
input TechnologyLogo_arr_rel_insert_input {
  data: [TechnologyLogo_insert_input!]!
  "on conflict condition"
  on_conflict: TechnologyLogo_on_conflict
}

"Boolean expression to filter rows from the table \"TechnologyLogo\". All fields are combined with a logical 'AND'."
input TechnologyLogo_bool_exp {
  Image: Image_bool_exp
  _and: [TechnologyLogo_bool_exp!]
  _not: TechnologyLogo_bool_exp
  _or: [TechnologyLogo_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  imageId: uuid_comparison_exp
  isOnHomepage: Boolean_comparison_exp
  name: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"input type for inserting data into table \"TechnologyLogo\""
input TechnologyLogo_insert_input {
  Image: Image_obj_rel_insert_input
  createdAt: timestamp
  id: uuid
  imageId: uuid
  isOnHomepage: Boolean
  name: String
  updatedAt: timestamp
}

"order by max() on columns of table \"TechnologyLogo\""
input TechnologyLogo_max_order_by {
  createdAt: order_by
  id: order_by
  imageId: order_by
  name: order_by
  updatedAt: order_by
}

"order by min() on columns of table \"TechnologyLogo\""
input TechnologyLogo_min_order_by {
  createdAt: order_by
  id: order_by
  imageId: order_by
  name: order_by
  updatedAt: order_by
}

"on conflict condition type for table \"TechnologyLogo\""
input TechnologyLogo_on_conflict {
  constraint: TechnologyLogo_constraint!
  update_columns: [TechnologyLogo_update_column!]! = []
  where: TechnologyLogo_bool_exp
}

"Ordering options when selecting data from \"TechnologyLogo\"."
input TechnologyLogo_order_by {
  Image: Image_order_by
  createdAt: order_by
  id: order_by
  imageId: order_by
  isOnHomepage: order_by
  name: order_by
  updatedAt: order_by
}

"primary key columns input for table: TechnologyLogo"
input TechnologyLogo_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"TechnologyLogo\""
input TechnologyLogo_set_input {
  createdAt: timestamp
  id: uuid
  imageId: uuid
  isOnHomepage: Boolean
  name: String
  updatedAt: timestamp
}

"order by aggregate values of table \"User\""
input User_aggregate_order_by {
  count: order_by
  max: User_max_order_by
  min: User_min_order_by
}

"input type for inserting array relation for remote table \"User\""
input User_arr_rel_insert_input {
  data: [User_insert_input!]!
  "on conflict condition"
  on_conflict: User_on_conflict
}

"Boolean expression to filter rows from the table \"User\". All fields are combined with a logical 'AND'."
input User_bool_exp {
  Person: Person_bool_exp
  _and: [User_bool_exp!]
  _not: User_bool_exp
  _or: [User_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  password: String_comparison_exp
  personId: uuid_comparison_exp
  role: Role_comparison_exp
  updatedAt: timestamp_comparison_exp
  username: String_comparison_exp
}

"input type for inserting data into table \"User\""
input User_insert_input {
  Person: Person_obj_rel_insert_input
  createdAt: timestamp
  id: uuid
  password: String
  personId: uuid
  role: Role
  updatedAt: timestamp
  username: String
}

"order by max() on columns of table \"User\""
input User_max_order_by {
  createdAt: order_by
  id: order_by
  password: order_by
  personId: order_by
  updatedAt: order_by
  username: order_by
}

"order by min() on columns of table \"User\""
input User_min_order_by {
  createdAt: order_by
  id: order_by
  password: order_by
  personId: order_by
  updatedAt: order_by
  username: order_by
}

"on conflict condition type for table \"User\""
input User_on_conflict {
  constraint: User_constraint!
  update_columns: [User_update_column!]! = []
  where: User_bool_exp
}

"Ordering options when selecting data from \"User\"."
input User_order_by {
  Person: Person_order_by
  createdAt: order_by
  id: order_by
  password: order_by
  personId: order_by
  role: order_by
  updatedAt: order_by
  username: order_by
}

"primary key columns input for table: User"
input User_pk_columns_input {
  id: uuid!
}

"input type for updating data in table \"User\""
input User_set_input {
  createdAt: timestamp
  id: uuid
  password: String
  personId: uuid
  role: Role
  updatedAt: timestamp
  username: String
}

"Boolean expression to compare columns of type \"float8\". All fields are combined with logical 'AND'."
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
